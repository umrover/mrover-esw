{# Python script should input message_dict -#}
/* {{dbc_name}} */
{# Include C libraries #}
{%- for lib in libs %}
#include <{{ lib }}>
{%- endfor %}

#ifndef {{dbc_name}}_H
#define {{dbc_name}}_H
{#- Struct definitions #}
{% for msg in message_dict %}
class {{ message_dict[msg].name }} {
    public:
    // Signals
    {%- set signals = message_dict[msg].signal_dict %}
    {%- for signal in signals %}
    {{signals[signal].data_type}} {{signal}};
    {%- endfor %}

    // Byte array representation of message
    uint8_t msg_arr[{{ message_dict[msg].byte_length }}];

    // Constructors serve as our encode/decode functions
    
    // Decode into message class format
    {{ message_dict[msg].name }}(uint8_t * byte_arr) {
    {%- for signal in signals %}
    {%- if signals[signal].bit_length == 1 %}
    {%- else %}

        uint{{ signals[signal].bit_length }}_t temp_{{ signal }} = 0;
        for (uint8_t i = 0; i < {{ signals[signal].byte_length }}; ++i) {
            temp_{{ signal }}  |= byte_arr[i] << 8*i;
        }
        {{ signal }} = std::bit_cast<{{ signals[signal].data_type }}>(temp_{{ signal }});
    {%- endif %}
    {%- endfor %}
    }

    // Encode into byte array format
    {{ message_dict[msg].name }}(
    {%- for signal in signals %}
        {%- if loop.last %}
        {{signals[signal].data_type}} {{signal}}
        {%- else %}
        {{signals[signal].data_type}} {{signal}},
        {%- endif %}
    {%- endfor %}
    ) {
        uint32_t i = 0;
    {%- for signal in signals %}
    {%- if signals[signal].bit_length == 1 %}
    {%- else %}
        for (uint8_t j = 0; j < {{ signals[signal].byte_length }}; ++i, ++j) {
            msg_arr[i] = (std::bit_cast<uint{{ signals[signal].bit_length }}_t>({{ signal }}) >> 8*j) & 0xFF;
        }
    {%- endif %}
    {%- endfor %}
    }
};
{% endfor %}

#endif /* {{dbc_name}} */
