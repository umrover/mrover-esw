/* {{dbc_name}}.hpp */
/* THIS FILE IS AUTO-GENERATED BY "can_header_gen.py" */
/* Generated on: {{ timestamp }} */

#pragma once

{# Include C libraries #}
{%- for lib in libs %}
#include <{{ lib }}>
{%- endfor %}


namespace mrover {

    static constexpr uint32_t CAN_NODE_MASK = 0xF;

    {#- Struct definitions (omitted for brevity, assume they remain the same) #}
    {% for msg_id, msg in message_dict.items() %}
    class {{ msg.name }} {
        public:
        static constexpr uint32_t CAN_ID = {{ msg_id }};
        static constexpr uint32_t BASE_ID = CAN_ID & ~CAN_NODE_MASK;
        {%- set signals = msg.signal_dict %}
        {%- for sig_name, sig_data in signals.items() %}
        {{sig_data.data_type}} {{sig_name}};
        {%- endfor %}

        uint8_t msg_arr[{{ msg.byte_length }}];

        explicit {{ msg.name }}(uint8_t const * byte_arr) {
            std::memset(msg_arr, 0, {{ msg.byte_length }});
            std::memcpy(msg_arr, byte_arr, {{ msg.byte_length }});

            [[maybe_unused]] uint32_t i = 0;
        {%- set ns = namespace(boolIter = 0) %}
        {%- for sig_name, sig_data in signals.items() %}

        {%- if sig_data.bit_length == 1 %}
            {%- if ns.boolIter == 8 %}
            {%- set ns.boolIter = 0 %}
            ++i;
            {%- endif %}
            {{ sig_name }} = (byte_arr[i] >> {{ ns.boolIter }}) & 0b1;
            {%- set ns.boolIter = ns.boolIter + 1 %}

        {%- else %}
            uint{{ sig_data.bit_length if sig_data.bit_length > 8 else 8 }}_t temp_{{ sig_name }} = 0;

            for (uint8_t j = 0; j < {{ sig_data.byte_length }}; ++j) {
                temp_{{ sig_name }} |= static_cast<uint{{ sig_data.bit_length if sig_data.bit_length > 8 else 8 }}_t>(byte_arr[i]) << (8*j);
                ++i;
            }
            {{ sig_name }} = std::bit_cast<{{ sig_data.data_type }}>(temp_{{ sig_name }});
        {%- endif %}
        {%- endfor %}
        }

        {{ msg.name }}(
        {%- if signals %}
        {%- for sig_name, sig_data in signals.items() %}
            {{ sig_data.data_type }} const {{ sig_name }}_in
            {%- if not loop.last %}, {% endif %}
        {%- endfor %}
        ) :
        {%- for sig_name, sig_data in signals.items() %}
            {{ sig_name }}({{ sig_name }}_in)
            {%- if not loop.last %}, {% endif %}
        {%- endfor %}
        {%- else %}
        )
        {%- endif %}
         {
            std::memset(msg_arr, 0, {{ msg.byte_length }});

            [[maybe_unused]] uint32_t i = 0;
        {%- set ns = namespace(boolIter = 0) %}
        {%- for sig_name, sig_data in signals.items() %}

        {%- if sig_data.bit_length == 1 %}
            {%- if ns.boolIter == 8 %}
            {%- set ns.boolIter = 0 %}
            ++i;
            {%- endif %}

            if({{ sig_name }}) {
                msg_arr[i] |= (1 << {{ ns.boolIter }});
            } else {
                msg_arr[i] &= ~(1 << {{ ns.boolIter }});
            }
            {%- set ns.boolIter = ns.boolIter + 1 %}

        {%- else %}
            for (uint8_t j = 0; j < {{ sig_data.byte_length }}; ++j) {
                msg_arr[i] = (std::bit_cast<uint{{ sig_data.bit_length if sig_data.bit_length > 8 else 8 }}_t>({{ sig_name }}) >> (8*j)) & 0xFF;
                ++i;
            }
        {%- endif %}
        {%- endfor %}
        }
    };
    {% endfor %}

    constexpr std::size_t dlc_to_size(uint32_t const dlc) {
        if (dlc <= FDCAN_DLC_BYTES_8) return dlc;
        if (dlc == FDCAN_DLC_BYTES_12) return 12;
        if (dlc == FDCAN_DLC_BYTES_16) return 16;
        if (dlc == FDCAN_DLC_BYTES_20) return 20;
        if (dlc == FDCAN_DLC_BYTES_24) return 24;
        if (dlc == FDCAN_DLC_BYTES_32) return 32;
        if (dlc == FDCAN_DLC_BYTES_48) return 48;
        if (dlc == FDCAN_DLC_BYTES_64) return 64;
        return 0;
    }

    template<typename T>
    concept CanMessage = requires(T const c_msg, uint8_t const* byte_arr) {
        { T{byte_arr} };
        { c_msg.msg_arr } -> std::convertible_to<const uint8_t*>;
        { T::BASE_ID } -> std::convertible_to<uint32_t const>;
    };

    using {{ dbc_name }}Msg_t = std::variant<
    {%- for type in message_types %}
        {{ type }}{% if not loop.last %},{% endif %}
    {%- endfor %}
    >;

#ifdef HAL_FDCAN_MODULE_ENABLED
    class {{ dbc_name }}Handler {
    public:
        static constexpr uint32_t CAN_NODE_MASK = 0xF;

        {{ dbc_name }}Handler() = default;

        explicit {{ dbc_name }}Handler(FDCAN&& fdcan_driver)
            : m_fdcan{std::move(fdcan_driver)} {}

        struct CanSenderVisitor {
            {{ dbc_name }}Handler* m_parent;
            uint32_t const m_node_id;

            CanSenderVisitor({{ dbc_name }}Handler* parent, uint32_t node_id)
                : m_parent(parent), m_node_id(node_id) {}

            template<typename MessageT>
            void operator()(MessageT const& message) const
                requires CanMessage<MessageT>
            {
                uint32_t const base_id = MessageT::BASE_ID;

                uint32_t const masked_node_id = m_node_id & CAN_NODE_MASK;
                uint32_t const final_id = base_id | masked_node_id;

                std::span<uint8_t const> const data(message.msg_arr, sizeof(message.msg_arr));
                this->m_parent->m_fdcan.send(final_id,
                    std::string_view(reinterpret_cast<char const*>(data.data()), data.size())
                );
            }
        };

        void send(
            {{ dbc_name }}Msg_t const& message_variant,
            uint32_t const node_id)
        {
            CanSenderVisitor sender(this, node_id);
            std::visit(sender, message_variant);
        }

        [[nodiscard]] auto receive(uint32_t const node_id) -> std::optional<{{ dbc_name }}Msg_t> {
            FDCAN_RxHeaderTypeDef header;
            uint8_t data_buffer[FDCAN_MAX_FRAME_SIZE];

            if (std::span<uint8_t> const data_span{data_buffer, FDCAN_MAX_FRAME_SIZE}; m_fdcan.receive(&header, data_span)) {
                uint32_t const received_base_id = header.Identifier & ~CAN_NODE_MASK;
                uint32_t const received_node_id = header.Identifier & CAN_NODE_MASK;
                if (received_node_id != (node_id & CAN_NODE_MASK)) {
                    return std::nullopt;
                }

                std::size_t const received_size = dlc_to_size(header.DataLength);
                std::span<uint8_t const> const received_data(data_buffer, received_size);

                switch (received_base_id) {
            {% for msg in messages_for_handler %}
                    case ({{ msg.id }} & ~CAN_NODE_MASK): {
                        return {{ dbc_name }}Msg_t{ {{ msg.name }}{received_data.data()} };
                    }
            {%- endfor %}
                    default:
                        return std::nullopt;
                }
            }
            return std::nullopt;
        }

        FDCAN& get_driver() { return m_fdcan; }

    private:
        FDCAN m_fdcan;
    };
#else // HAL_FDCAN_MODULE_ENABLED
    // TODO: build jetson implementation here
    class __attribute__((unavailable("enable 'FDCAN' in STM32CubeMX to use mrover::{{ dbc_name }}Handler"))) {{ dbc_name }}Handler {
    public:
        template<typename... Args>
        explicit {{ dbc_name }}Handler(Args&&... args) {}
    };
#endif // HAL_FDCAN_MODULE_ENABLED

    template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
    template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;


} // namespace mrover
