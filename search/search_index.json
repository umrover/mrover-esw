{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MRover Embedded Software The embedded software team (ESW) of MRover writes the driver code that allows the other programming subteams to utilize the electronic equipment on the rover. ESW works primarily with libraries in C, C++, and Python to abstract the functions needed by the other teams for easy use. To do this we use different communication protocols such as CAN and I2C to transmit and receive data from sensors, motors, and various other components. New to ESW? Check out the getting started page for developer setup and starter projects. Overview ESW is split into two groups: Controls and Telemetry. The main difference is simply the subject matter of their projects. Controls handles the control systems on the rover, dealing mainly with brushless and brushed DC motors. We currently use moteus-r4.11 and moteus-n1 brushless controllers from mjbots, however we aim to replace these entirely with our own custom brushless controller. Our brushed controllers are already fully custom and developed by us. Telemetry handles the data and sensing systems on the rover, dealing mainly with the science system.","title":"Home"},{"location":"#mrover-embedded-software","text":"The embedded software team (ESW) of MRover writes the driver code that allows the other programming subteams to utilize the electronic equipment on the rover. ESW works primarily with libraries in C, C++, and Python to abstract the functions needed by the other teams for easy use. To do this we use different communication protocols such as CAN and I2C to transmit and receive data from sensors, motors, and various other components. New to ESW? Check out the getting started page for developer setup and starter projects.","title":"MRover Embedded Software"},{"location":"#overview","text":"ESW is split into two groups: Controls and Telemetry. The main difference is simply the subject matter of their projects. Controls handles the control systems on the rover, dealing mainly with brushless and brushed DC motors. We currently use moteus-r4.11 and moteus-n1 brushless controllers from mjbots, however we aim to replace these entirely with our own custom brushless controller. Our brushed controllers are already fully custom and developed by us. Telemetry handles the data and sensing systems on the rover, dealing mainly with the science system.","title":"Overview"},{"location":"getting-started/intro/","text":"Introduction Welcome to MRover Embedded Software! The Getting Started section is designed to get you up and running as smooth as possible. It consists of three starter projects to help you get experience with using microcontrollers and communication protocols. There is also useful information linked below to supplement the starter projects. Starter Projects All new members are asked to complete the following: Install STM32CubeIDE Starter Project: LED Starter Project: Servo Part 1 Starter Project: Servo Part 2 Starter Project: Temperature and Humidity Sensor As everyone comes from varying levels of experience, extra information is provided in these docs to assist the learning process. Please do not hesitate to ask for help! Some helpful references include: Intro to Nucleos Communication Protocols","title":"Introduction"},{"location":"getting-started/intro/#introduction","text":"Welcome to MRover Embedded Software! The Getting Started section is designed to get you up and running as smooth as possible. It consists of three starter projects to help you get experience with using microcontrollers and communication protocols. There is also useful information linked below to supplement the starter projects.","title":"Introduction"},{"location":"getting-started/intro/#starter-projects","text":"All new members are asked to complete the following: Install STM32CubeIDE Starter Project: LED Starter Project: Servo Part 1 Starter Project: Servo Part 2 Starter Project: Temperature and Humidity Sensor As everyone comes from varying levels of experience, extra information is provided in these docs to assist the learning process. Please do not hesitate to ask for help! Some helpful references include: Intro to Nucleos Communication Protocols","title":"Starter Projects"},{"location":"getting-started/starter/led/","text":"LED Starter Project About This tutorial is intended to get you more familiar with a Nucleo (with STM32G431RB MCU) and the Cube IDE. You will be asked to develop code such that the LED on the Nucleo will light up whenever the Nucleo\u2019s button is pressed down. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck! Instructions As mentioned earlier, the goal is to make sure that the button is able to activate the LED. As you walk through the guide, keep the following questions in mind: Which pin is linked to the button and which pin is linked to the LED? Are those pins activated on the .ioc file? Have you looked through the HAL drivers to see how to read from and write to pins? Do you know which pins have to be read from and which pins need to be written to? Do you know what to write to the pin that needs to be written to and when? Prerequisites STM32CubeIDE installed STM32G431RB Nucleo (pictured below) Guide Open up Cube IDE and create a new project called tutorial by following the steps in the Cube IDE New Project Guide . When creating a new project, the pins are not configured by default. This matters because on the Nucleo, the button and the LED are already connected to a particular pin so we need to change the pin's functionality if we want to use it. In order to determine which pins are connected to the button and the LED, one can visit this page. On this page, you will find some pinouts. Based on the pinouts, you should be able to tell that the button is connected to pin PC13 and that the LED is connected to PA5. Head back to the Cube IDE and if the .ioc file is not open already, open it from the Project Explorer located on the left. You should be able to see a graphical interface with the chip on it. Some images may include STM32F303RETx instead of STM32G431RBTx : Please ignore the differences! The first thing we want to do is set PC13 pin (which is connected to the push button) to be a GPIO input. This means that the pin will be set so that we can choose to read digital input in our code. Reading digital input means that we can read 3.3V as high (logic 1) and read 0V as low (logic 0). This is relevant because this means that we can be able to tell if the push button is pressed down or released. On the graphical interface (also called the .ioc file), locate PC13 and click on it. Then select GPIO_Input to change its configuration. The next thing we want to do is set PA5 (which is connected to the LED) to be a GPIO output. This means that we will be able to make the pin either be set to 3.3V (high) or 0V (low). By default, the pin starts off as low. On the .ioc file, locate PA5 and click on it. Select GPIO_Output to change its configuration. You may need to scroll down a bit. Note that the pin may already be set to GPIO_Output by default, so you may choose to not do anything new. Make sure to save your changes by saving the file. Either run the keyboard shortcut Ctrl + S on your keyboard or click on File -> Save. You will then see a window asking if you want to generate Code. Click Yes. You may also see a window asking about opening the associated perspective. Click Yes. We have now successfully configured our pins and generated the code for it. Now it is time to write the logic to link the button and the LED together. Begin by opening up the src/main.c file. When writing code, you will only want to write in specific sections. A good rule of thumb is to only put your code in between where it says USER CODE BEGIN and USER CODE END . This is necessary because otherwise, the automatic code generation from the Cube IDE will overwrite and delete your code. We will be using the HAL library so that we can call a single function to perform operations such as reading digital input and writing digital output. The HAL functions that we are interested in are HAL_GPIO_ReadPin(gpio-port, gpio-pin) and HAL_GPIO_WritePin(gpio-port, gpio-pin, pin-state) . See below for a demo on how we can access data in our case. When reading in the pin state PC13, do note that the value read depends on if the button is pushed down or released AND if the button is active low or active high. In our case, the button is active high. This means that when the button is pushed down, the value returned is a 1. Based on this information, you should now be able to implement logic on how to link the button to the LED. If you need additional resources, you may choose to refer to this guide on how to GPIO pins and buttons. Also, you are always welcome to ask another member for help! After writing your code, you will most certainly want to build and run your program on actual hardware. Connect an STM32G431RB Nucleo board to your computer via USB. Ask an experienced member or an ESW lead if you need assistance in obtaining such hardware. Before building your program, ensure that all relevant files have been saved to ensure that code generation has been done. Then, build your project by clicking Project \u2192 Build All (or Project \u2192 Build Project ) or using the keyboard shortcut Ctrl + B . After building your project, you will see the console which will tell you whether or not your project built successfully. As long as there are no errors, then your project built successfully. You should also look over the warnings if you have any since those hint at potential problems in your code. Once your project has built successfully, you will now want to flash the code onto your Nucleo and let it run. Click on Run \u2192 Run . Make sure that your Nucleo device is connected to your computer via USB or else this will not work. Now press down on the button and see if the LED properly lights up. If they do, congratulations! You have completed your first ESW project! Be sure to show a demo of your project to an ESW lead. If you need help debugging, feel free to ask any of the subteam leads or any of the other members. Useful Resources You may or may not need all of these links in the future. Board Reference Manual Chip Datasheet HAL-Driver Pinout","title":"LED"},{"location":"getting-started/starter/led/#led-starter-project","text":"","title":"LED Starter Project"},{"location":"getting-started/starter/led/#about","text":"This tutorial is intended to get you more familiar with a Nucleo (with STM32G431RB MCU) and the Cube IDE. You will be asked to develop code such that the LED on the Nucleo will light up whenever the Nucleo\u2019s button is pressed down. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck!","title":"About"},{"location":"getting-started/starter/led/#instructions","text":"As mentioned earlier, the goal is to make sure that the button is able to activate the LED. As you walk through the guide, keep the following questions in mind: Which pin is linked to the button and which pin is linked to the LED? Are those pins activated on the .ioc file? Have you looked through the HAL drivers to see how to read from and write to pins? Do you know which pins have to be read from and which pins need to be written to? Do you know what to write to the pin that needs to be written to and when?","title":"Instructions"},{"location":"getting-started/starter/led/#prerequisites","text":"STM32CubeIDE installed STM32G431RB Nucleo (pictured below)","title":"Prerequisites"},{"location":"getting-started/starter/led/#guide","text":"Open up Cube IDE and create a new project called tutorial by following the steps in the Cube IDE New Project Guide . When creating a new project, the pins are not configured by default. This matters because on the Nucleo, the button and the LED are already connected to a particular pin so we need to change the pin's functionality if we want to use it. In order to determine which pins are connected to the button and the LED, one can visit this page. On this page, you will find some pinouts. Based on the pinouts, you should be able to tell that the button is connected to pin PC13 and that the LED is connected to PA5. Head back to the Cube IDE and if the .ioc file is not open already, open it from the Project Explorer located on the left. You should be able to see a graphical interface with the chip on it. Some images may include STM32F303RETx instead of STM32G431RBTx : Please ignore the differences! The first thing we want to do is set PC13 pin (which is connected to the push button) to be a GPIO input. This means that the pin will be set so that we can choose to read digital input in our code. Reading digital input means that we can read 3.3V as high (logic 1) and read 0V as low (logic 0). This is relevant because this means that we can be able to tell if the push button is pressed down or released. On the graphical interface (also called the .ioc file), locate PC13 and click on it. Then select GPIO_Input to change its configuration. The next thing we want to do is set PA5 (which is connected to the LED) to be a GPIO output. This means that we will be able to make the pin either be set to 3.3V (high) or 0V (low). By default, the pin starts off as low. On the .ioc file, locate PA5 and click on it. Select GPIO_Output to change its configuration. You may need to scroll down a bit. Note that the pin may already be set to GPIO_Output by default, so you may choose to not do anything new. Make sure to save your changes by saving the file. Either run the keyboard shortcut Ctrl + S on your keyboard or click on File -> Save. You will then see a window asking if you want to generate Code. Click Yes. You may also see a window asking about opening the associated perspective. Click Yes. We have now successfully configured our pins and generated the code for it. Now it is time to write the logic to link the button and the LED together. Begin by opening up the src/main.c file. When writing code, you will only want to write in specific sections. A good rule of thumb is to only put your code in between where it says USER CODE BEGIN and USER CODE END . This is necessary because otherwise, the automatic code generation from the Cube IDE will overwrite and delete your code. We will be using the HAL library so that we can call a single function to perform operations such as reading digital input and writing digital output. The HAL functions that we are interested in are HAL_GPIO_ReadPin(gpio-port, gpio-pin) and HAL_GPIO_WritePin(gpio-port, gpio-pin, pin-state) . See below for a demo on how we can access data in our case. When reading in the pin state PC13, do note that the value read depends on if the button is pushed down or released AND if the button is active low or active high. In our case, the button is active high. This means that when the button is pushed down, the value returned is a 1. Based on this information, you should now be able to implement logic on how to link the button to the LED. If you need additional resources, you may choose to refer to this guide on how to GPIO pins and buttons. Also, you are always welcome to ask another member for help! After writing your code, you will most certainly want to build and run your program on actual hardware. Connect an STM32G431RB Nucleo board to your computer via USB. Ask an experienced member or an ESW lead if you need assistance in obtaining such hardware. Before building your program, ensure that all relevant files have been saved to ensure that code generation has been done. Then, build your project by clicking Project \u2192 Build All (or Project \u2192 Build Project ) or using the keyboard shortcut Ctrl + B . After building your project, you will see the console which will tell you whether or not your project built successfully. As long as there are no errors, then your project built successfully. You should also look over the warnings if you have any since those hint at potential problems in your code. Once your project has built successfully, you will now want to flash the code onto your Nucleo and let it run. Click on Run \u2192 Run . Make sure that your Nucleo device is connected to your computer via USB or else this will not work. Now press down on the button and see if the LED properly lights up. If they do, congratulations! You have completed your first ESW project! Be sure to show a demo of your project to an ESW lead. If you need help debugging, feel free to ask any of the subteam leads or any of the other members.","title":"Guide"},{"location":"getting-started/starter/led/#useful-resources","text":"You may or may not need all of these links in the future. Board Reference Manual Chip Datasheet HAL-Driver Pinout","title":"Useful Resources"},{"location":"getting-started/starter/servo/part1-pwm/","text":"Servo Starter Project - Part 1 - PWM This starter project is made up of two parts: PWM and CAN. This is Part 1 - PWM. By the end of this part, you should have an understanding of timers and PWM (pulse width modulation) signals. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck! Prerequisites STM32CubeIDE installed LED Project completed and shown to an ESW lead Git setup STM32G431RB Nucleo SG90 Servo Intro As mentioned earlier, by the end of the project you should be able to drive a servo. This project will also teach some coding practices used for STM32 code. Similar to our real code, this starter project will be in C++. While you are working through the project, keep the following in mind: How could you document your code so that others can easily read and understand it? How could you write your code so that it can easily be adjusted for different pins, different number of servos, etc.? Guide 1. Setting up the project Since you already have practice creating a project, you will only need to clone and open the premade STM32 project for this starter project. Go to this repository , click the \"Code\" tab, and copy the SSH URL. You now have the URL you need to clone the project. Clone the project onto your local computer by running the following command in your terminal: git clone link-copied-in-above-step Enter the directory: cd mrover-esw Then, create a new branch for yourself git switch -c starter/your-first-name Open STM32CubeIDE and open the Servo Part 1 starter project (the directory named p1-pwm ). Follow the following guide to open an existing project if you do not know how to do so. 2. PWM timer configuration Once the .ioc is open, configure the pins for PWM. Select the PC0 pin on the chip in the .ioc and change it to TIM1_CH1. On the left side of the .ioc file, under Timers, select TIM1 (shown below). Change Channel1 from \"Disable\" to \"PWM Generation CH1\" (shown below). We will now have to configure two values\u2014Prescaler and Counter Period\u2014in order to correctly set up this PWM timer. These values are located in the \"Parameter Settings\" and must be calculated. Refer to the timer reference guide for information on calculating these values. Read the datasheet for the servo and determine what PSC and ARR should be given that the clock frequency of the Nucleo is 72MHz. Once you have determined and edited the timer config, save the file and generate code. Note: you can always come back to the .ioc to make changes. 3. Opening the header file Having a servo object will make it easier to adjust the number servos or where the servos are in the future, so for good practice, we will create a Servo class and declare any member variables and member functions in a header file. On the menu to the left, in Core \u2192 Inc , open the header file named servo.hpp . Here, we can see the interface for the Servo class that we will be implementing. The Servo class has 2 member variables: TIM_HandleTypeDef *timer : this tells the STM which timer is being used to generate the PWM signal uint32_t channel : this tells the STM which channel is being used for the PWM signal It also has 3 member functions: A constructor that takes in the timer and channel for the PWM signal A function start_servo() that starts the PWM generation A function set_servo_angle(int angle) that moves the servo to the specified angle 4. Implementing Servo functions Now that we know the interface for the Servo class, it's time to implement the functions. On the menu to the left, in Core \u2192 Src , open the C++ source file named servo.cpp . To start the servo, you must initialize the timer used to generate the PWM signal. To do this, use HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel) . Find more information about this built-in HAL function here . When implementing set_servo_angle, keep in mind what PWM signal corresponds to what angle. Check back on the servo datasheet to determine this. In order to set the CCR register to change the PWM signal, you can use __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) . Below is information on this function: /** * @brief Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function. * @param __HANDLE__ TIM handle. * @param __CHANNEL__ TIM Channels to be configured. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @arg TIM_CHANNEL_5: TIM Channel 5 selected * @arg TIM_CHANNEL_6: TIM Channel 6 selected * @param __COMPARE__ specifies the Capture Compare register new value. * @retval None */ #define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) 5. Testing your servo functions Now that we have implemented our Servo class, it's time to test it out. Since this is a C++ project, we will not be using the main.c . Instead, navigate to Core \u2192 Src and open new_main.cpp . In the new_main() function, create a new Servo using the constructor. The timer parameter for should be a TIM_HandleTypeDef* . The name for the TIM_Handle that is being used is at the top of new_main.c . The channel parameter should correspond with which timer channel you are using (remember we set our pin to TIM1_CH1). Now, we can start the servo using the start_servo() function we created. Then, in the while(1) loop, change the angle of the servo a few times to make sure your set_servo_angle() function works and that the PSC and ARR you selected in the .ioc are correct. Between each function call make sure to add a delay (Hint: there is a built in HAL function for delays). When you are satisfied with your code, make sure it builds and then get a Nucleo, a logic analyzer, and some jumper cables to check your PWM signals. If you think the PWM signals are correct based on the datasheet , you can test your code on a servo. If you are unsure, just ask for help! Logic Analyzer The simplest method for debugging a digital signal is often to use a logic analyzer. Please install Logic on your laptop. To use Logic, connect PC0 to one of the pins of the logic analyzer and make sure the logic analyzer is grounded to the Nucleo. Then, flash the code and press the play button. If you wrote code in the main while loop to change the servo angle a few times (which you should), you'll notice the signal in Logic changing. Play around with Logic: Zoom in and out Pause the display Mouse over the different parts of the signal Try to understand what all the different numbers mean Wiring the Servo In order to properly wire the servo, first consult the datasheet . How much voltage does the servo need? Which wires are signal, power, and ground? Using a Breadboard A breadboard is broken into two sets of long rails on the outside edges of the board and multiple shorter rails on the inner part of the board. These rails allow for easy connections between wires on the same rail. Below is a picture depicting these rails. In order for the signal to work, the servo and the Nucleo must have a common ground. Connect the servo's ground wire to one of the ground pins on the Nucleo, the power to the appropriate power pin on the Nucleo, and the signal wire to PC0. If you have any questions, don't be afraid to reach out to an ESW lead or SAM(s).","title":"Part 1 - PWM"},{"location":"getting-started/starter/servo/part1-pwm/#servo-starter-project-part-1-pwm","text":"This starter project is made up of two parts: PWM and CAN. This is Part 1 - PWM. By the end of this part, you should have an understanding of timers and PWM (pulse width modulation) signals. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck!","title":"Servo Starter Project - Part 1 - PWM"},{"location":"getting-started/starter/servo/part1-pwm/#prerequisites","text":"STM32CubeIDE installed LED Project completed and shown to an ESW lead Git setup STM32G431RB Nucleo SG90 Servo","title":"Prerequisites"},{"location":"getting-started/starter/servo/part1-pwm/#intro","text":"As mentioned earlier, by the end of the project you should be able to drive a servo. This project will also teach some coding practices used for STM32 code. Similar to our real code, this starter project will be in C++. While you are working through the project, keep the following in mind: How could you document your code so that others can easily read and understand it? How could you write your code so that it can easily be adjusted for different pins, different number of servos, etc.?","title":"Intro"},{"location":"getting-started/starter/servo/part1-pwm/#guide","text":"","title":"Guide"},{"location":"getting-started/starter/servo/part1-pwm/#1-setting-up-the-project","text":"Since you already have practice creating a project, you will only need to clone and open the premade STM32 project for this starter project. Go to this repository , click the \"Code\" tab, and copy the SSH URL. You now have the URL you need to clone the project. Clone the project onto your local computer by running the following command in your terminal: git clone link-copied-in-above-step Enter the directory: cd mrover-esw Then, create a new branch for yourself git switch -c starter/your-first-name Open STM32CubeIDE and open the Servo Part 1 starter project (the directory named p1-pwm ). Follow the following guide to open an existing project if you do not know how to do so.","title":"1. Setting up the project"},{"location":"getting-started/starter/servo/part1-pwm/#2-pwm-timer-configuration","text":"Once the .ioc is open, configure the pins for PWM. Select the PC0 pin on the chip in the .ioc and change it to TIM1_CH1. On the left side of the .ioc file, under Timers, select TIM1 (shown below). Change Channel1 from \"Disable\" to \"PWM Generation CH1\" (shown below). We will now have to configure two values\u2014Prescaler and Counter Period\u2014in order to correctly set up this PWM timer. These values are located in the \"Parameter Settings\" and must be calculated. Refer to the timer reference guide for information on calculating these values. Read the datasheet for the servo and determine what PSC and ARR should be given that the clock frequency of the Nucleo is 72MHz. Once you have determined and edited the timer config, save the file and generate code. Note: you can always come back to the .ioc to make changes.","title":"2. PWM timer configuration"},{"location":"getting-started/starter/servo/part1-pwm/#3-opening-the-header-file","text":"Having a servo object will make it easier to adjust the number servos or where the servos are in the future, so for good practice, we will create a Servo class and declare any member variables and member functions in a header file. On the menu to the left, in Core \u2192 Inc , open the header file named servo.hpp . Here, we can see the interface for the Servo class that we will be implementing. The Servo class has 2 member variables: TIM_HandleTypeDef *timer : this tells the STM which timer is being used to generate the PWM signal uint32_t channel : this tells the STM which channel is being used for the PWM signal It also has 3 member functions: A constructor that takes in the timer and channel for the PWM signal A function start_servo() that starts the PWM generation A function set_servo_angle(int angle) that moves the servo to the specified angle","title":"3. Opening the header file"},{"location":"getting-started/starter/servo/part1-pwm/#4-implementing-servo-functions","text":"Now that we know the interface for the Servo class, it's time to implement the functions. On the menu to the left, in Core \u2192 Src , open the C++ source file named servo.cpp . To start the servo, you must initialize the timer used to generate the PWM signal. To do this, use HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel) . Find more information about this built-in HAL function here . When implementing set_servo_angle, keep in mind what PWM signal corresponds to what angle. Check back on the servo datasheet to determine this. In order to set the CCR register to change the PWM signal, you can use __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) . Below is information on this function: /** * @brief Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function. * @param __HANDLE__ TIM handle. * @param __CHANNEL__ TIM Channels to be configured. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @arg TIM_CHANNEL_5: TIM Channel 5 selected * @arg TIM_CHANNEL_6: TIM Channel 6 selected * @param __COMPARE__ specifies the Capture Compare register new value. * @retval None */ #define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__)","title":"4. Implementing Servo functions"},{"location":"getting-started/starter/servo/part1-pwm/#5-testing-your-servo-functions","text":"Now that we have implemented our Servo class, it's time to test it out. Since this is a C++ project, we will not be using the main.c . Instead, navigate to Core \u2192 Src and open new_main.cpp . In the new_main() function, create a new Servo using the constructor. The timer parameter for should be a TIM_HandleTypeDef* . The name for the TIM_Handle that is being used is at the top of new_main.c . The channel parameter should correspond with which timer channel you are using (remember we set our pin to TIM1_CH1). Now, we can start the servo using the start_servo() function we created. Then, in the while(1) loop, change the angle of the servo a few times to make sure your set_servo_angle() function works and that the PSC and ARR you selected in the .ioc are correct. Between each function call make sure to add a delay (Hint: there is a built in HAL function for delays). When you are satisfied with your code, make sure it builds and then get a Nucleo, a logic analyzer, and some jumper cables to check your PWM signals. If you think the PWM signals are correct based on the datasheet , you can test your code on a servo. If you are unsure, just ask for help!","title":"5. Testing your servo functions"},{"location":"getting-started/starter/servo/part1-pwm/#logic-analyzer","text":"The simplest method for debugging a digital signal is often to use a logic analyzer. Please install Logic on your laptop. To use Logic, connect PC0 to one of the pins of the logic analyzer and make sure the logic analyzer is grounded to the Nucleo. Then, flash the code and press the play button. If you wrote code in the main while loop to change the servo angle a few times (which you should), you'll notice the signal in Logic changing. Play around with Logic: Zoom in and out Pause the display Mouse over the different parts of the signal Try to understand what all the different numbers mean","title":"Logic Analyzer"},{"location":"getting-started/starter/servo/part1-pwm/#wiring-the-servo","text":"In order to properly wire the servo, first consult the datasheet . How much voltage does the servo need? Which wires are signal, power, and ground?","title":"Wiring the Servo"},{"location":"getting-started/starter/servo/part1-pwm/#using-a-breadboard","text":"A breadboard is broken into two sets of long rails on the outside edges of the board and multiple shorter rails on the inner part of the board. These rails allow for easy connections between wires on the same rail. Below is a picture depicting these rails. In order for the signal to work, the servo and the Nucleo must have a common ground. Connect the servo's ground wire to one of the ground pins on the Nucleo, the power to the appropriate power pin on the Nucleo, and the signal wire to PC0. If you have any questions, don't be afraid to reach out to an ESW lead or SAM(s).","title":"Using a Breadboard"},{"location":"getting-started/starter/servo/part2-can/","text":"Servo Starter Project - Part 2 - CAN This starter project is made up of two parts: PWM and CAN. This is Part 2 - CAN. In this project, you will be using the CAN peripheral on the STM32G431RB Nucleo to send a CAN message to another Nucleo board. The message will contain information about the angle the servo should be set to. If you send a successful message, the servo on the other board should rotate to the specified angle. By the end of this part, you should have an understanding of the CAN (Controller Area Network) communication protocol. Just as a reminder, if you have any questions, feel free to reach out to any ESW lead or member. Before starting this project , please give the CAN info page a read. It will get you start on the basics of CAN communication. Do not read \"Using the Kvaser Bit Timing Calculator.\" Prerequisites STM32CubeIDE installed LED Starter Project completed and shown to an ESW lead Servo Part 1 Starter Project completed and shown to an ESW lead STM32G431RB Nucleo MCP2551 CAN tranceiver Guide 1. Setting up the project Assuming you have already completed the Servo Part 1 Starter Project, you will not have to clone the project again. Open STM32CubeIDE and open the Servo Part 2 starter project (the directory named p2-can ). 2. Understanding our CAN bus In order to send messages to the CAN bus, we need to understand how our CAN bus is set up. The servo board that we are sending messages to is set up to receive CAN 2.0B messages with an extended identifier at a baud rate of 500 kbps . It will only respond to messages with the identifier 2024 . It will then read only the first byte of the data payload and set the servo to the angle specified in that byte. The angle must be between 0 and 180 degrees. For example, if we send a message with the identifier 2024 and the data payload 90 (decimal), the servo will rotate to 90 degrees. 3. CAN configuration Once the .ioc is open, activate the FDCAN peripheral. We can do this by clicking on the FDCAN peripheral in the Connectivity tab on the left side of the .ioc. Then, check the Activated box. Next, we need to configure the timings for the CAN bus. Click on the Parameter Settings tab (as shown above). We will be using CAN 2.0B not CAN FD, so Frame Format should be set to \"Classic.\" Since we are using \"Classic,\" we do not need to worry about the data bit rate. We will only need to properly set the following values: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Again, please refer to the CAN info page for more information on these values. There is a very in depth guide to configuring these values for STM32 MCUs in the CAN FD Bit Timing section of the docs. However, for the purposes of this starter project, you can use this online calculator designed for STM32G4 boards. Our FDCAN peripheral is clocked at 72 MHz, and the CAN bus we are trying to communicate on is running at 500 kbps. The calculator will give you the values you need to input into the .ioc. Ignore all CAN FD related values in the calculator. For Nominal Sync Jump Width, make sure to read the note at the bottom of the calculator. After inputting the bit timing parameters, ensure that Nominal Baud Rate is 500,000 bit/s. You can now save the .ioc and generate the code. 4. Writing the CAN code In the main.c , you should see 6 TODOs. We will walk through each of them. As a reminder, when you are writing code, make sure to write within the /* USER CODE */ tags. This will ensure that your code is not overwritten when you regenerate the code. TODO 1: Create the necessary variables to send a CAN message In order to send a CAN message, we need to create two objects: The message header The message data The message header is an object of type FDCAN_TxHeaderTypeDef . This will store information about the CAN message we are sending, such as the identifier, the data length, the frame format, etc. The message data is an array of bytes that will be sent in the CAN message. In this project, we will only be sending one byte of data, which will represent the angle the servo should be set to. To declare a byte of data, you can use the uint8_t type. TODO 2: Start the CAN peripheral We'll notice that there towards the top of the main.c file, there is the following object: FDCAN_HandleTypeDef hfdcan1; This is the handle for the FDCAN peripheral. We will need to initialize the FDCAN peripheral using the HAL_FDCAN_Start function. This function takes in the handle for the FDCAN peripheral. We can use the following code snippet to start the FDCAN peripheral: HAL_FDCAN_Start(&hfdcan1); TODO 3: Form the CAN message header In this step, we will need to fill out the FDCAN_TxHeaderTypeDef object that we created in TODO 1 with the necessary information to send a CAN message. Below is the structure of the FDCAN_TxHeaderTypeDef object: /** * @brief FDCAN Tx header structure definition */ typedef struct { uint32_t Identifier; /*!< Specifies the identifier. This parameter must be a number between: - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID */ uint32_t IdType; /*!< Specifies the identifier type for the message that will be transmitted. This parameter can be a value of @ref FDCAN_id_type */ uint32_t TxFrameType; /*!< Specifies the frame type of the message that will be transmitted. This parameter can be a value of @ref FDCAN_frame_type */ uint32_t DataLength; /*!< Specifies the length of the frame that will be transmitted. This parameter can be a value of @ref FDCAN_data_length_code */ uint32_t ErrorStateIndicator; /*!< Specifies the error state indicator. This parameter can be a value of @ref FDCAN_error_state_indicator */ uint32_t BitRateSwitch; /*!< Specifies whether the Tx frame will be transmitted with or without bit rate switching. This parameter can be a value of @ref FDCAN_bit_rate_switching */ uint32_t FDFormat; /*!< Specifies whether the Tx frame will be transmitted in classic or FD format. This parameter can be a value of @ref FDCAN_format */ uint32_t TxEventFifoControl; /*!< Specifies the event FIFO control. This parameter can be a value of @ref FDCAN_EFC */ uint32_t MessageMarker; /*!< Specifies the message marker to be copied into Tx Event FIFO element for identification of Tx message status. This parameter must be a number between 0 and 0xFF */ } FDCAN_TxHeaderTypeDef; The following code snippet shows how to fill out the FDCAN_TxHeaderTypeDef object to send a Classic CAN (CAN 2.0) message with a standard identifier of 88 and a data length of 8 bytes: // In TODO 1: // FDCAN_TxHeaderTypeDef TxHeader; TxHeader.Identifier = 88; TxHeader.IdType = FDCAN_STANDARD_ID; TxHeader.TxFrameType = FDCAN_DATA_FRAME; TxHeader.DataLength = FDCAN_DLC_BYTES_8; TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE; TxHeader.BitRateSwitch = FDCAN_BRS_OFF; TxHeader.FDFormat = FDCAN_CLASSIC_CAN; TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS; TxHeader.MessageMarker = 0; We will need to fill out the FDCAN_TxHeaderTypeDef object with the correct values for the CAN message you are trying to send. Refer back to 2. Understanding our CAN bus for this information. TODO 4-6: Send a CAN message to rotate the servo Now that we have the CAN message header for all the messages we want to send, we can send the message using the HAL_FDCAN_AddMessageToTxFifoQ function. This function takes in the handle for the FDCAN peripheral, the message header, and the message data. Here is an example of how to send a CAN message to turn the servo to 45 degrees: // In TODO 1: // uint8_t TxData[1]; TxData[0] = 45; HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &TxHeader, TxData); 5. Testing the project We will now connect to the CAN bus that the other Nucleo board is connected to. We will be using the MCP2551 CAN transceiver to connect to the CAN bus. For access to the CAN bus, please ask an ESW lead. The CAN TX and RX pins on the STM32G431RB Nucleo can be found in the .ioc file. These pins should connect to the CAN TX and RX pins on the MCP2551 CAN transceiver. The CANH and CANL pins on the MCP2551 should connect to the CANH and CANL pins on the CAN bus. We will now be able to test the project. To do this, we will need to build and flash the code onto the STM32G431RB Nucleo board. Once you have flashed the code, you should see the servo rotate to the angle specified in the CAN messages.","title":"Part 2 - CAN"},{"location":"getting-started/starter/servo/part2-can/#servo-starter-project-part-2-can","text":"This starter project is made up of two parts: PWM and CAN. This is Part 2 - CAN. In this project, you will be using the CAN peripheral on the STM32G431RB Nucleo to send a CAN message to another Nucleo board. The message will contain information about the angle the servo should be set to. If you send a successful message, the servo on the other board should rotate to the specified angle. By the end of this part, you should have an understanding of the CAN (Controller Area Network) communication protocol. Just as a reminder, if you have any questions, feel free to reach out to any ESW lead or member. Before starting this project , please give the CAN info page a read. It will get you start on the basics of CAN communication. Do not read \"Using the Kvaser Bit Timing Calculator.\"","title":"Servo Starter Project - Part 2 - CAN"},{"location":"getting-started/starter/servo/part2-can/#prerequisites","text":"STM32CubeIDE installed LED Starter Project completed and shown to an ESW lead Servo Part 1 Starter Project completed and shown to an ESW lead STM32G431RB Nucleo MCP2551 CAN tranceiver","title":"Prerequisites"},{"location":"getting-started/starter/servo/part2-can/#guide","text":"","title":"Guide"},{"location":"getting-started/starter/servo/part2-can/#1-setting-up-the-project","text":"Assuming you have already completed the Servo Part 1 Starter Project, you will not have to clone the project again. Open STM32CubeIDE and open the Servo Part 2 starter project (the directory named p2-can ).","title":"1. Setting up the project"},{"location":"getting-started/starter/servo/part2-can/#2-understanding-our-can-bus","text":"In order to send messages to the CAN bus, we need to understand how our CAN bus is set up. The servo board that we are sending messages to is set up to receive CAN 2.0B messages with an extended identifier at a baud rate of 500 kbps . It will only respond to messages with the identifier 2024 . It will then read only the first byte of the data payload and set the servo to the angle specified in that byte. The angle must be between 0 and 180 degrees. For example, if we send a message with the identifier 2024 and the data payload 90 (decimal), the servo will rotate to 90 degrees.","title":"2. Understanding our CAN bus"},{"location":"getting-started/starter/servo/part2-can/#3-can-configuration","text":"Once the .ioc is open, activate the FDCAN peripheral. We can do this by clicking on the FDCAN peripheral in the Connectivity tab on the left side of the .ioc. Then, check the Activated box. Next, we need to configure the timings for the CAN bus. Click on the Parameter Settings tab (as shown above). We will be using CAN 2.0B not CAN FD, so Frame Format should be set to \"Classic.\" Since we are using \"Classic,\" we do not need to worry about the data bit rate. We will only need to properly set the following values: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Again, please refer to the CAN info page for more information on these values. There is a very in depth guide to configuring these values for STM32 MCUs in the CAN FD Bit Timing section of the docs. However, for the purposes of this starter project, you can use this online calculator designed for STM32G4 boards. Our FDCAN peripheral is clocked at 72 MHz, and the CAN bus we are trying to communicate on is running at 500 kbps. The calculator will give you the values you need to input into the .ioc. Ignore all CAN FD related values in the calculator. For Nominal Sync Jump Width, make sure to read the note at the bottom of the calculator. After inputting the bit timing parameters, ensure that Nominal Baud Rate is 500,000 bit/s. You can now save the .ioc and generate the code.","title":"3. CAN configuration"},{"location":"getting-started/starter/servo/part2-can/#4-writing-the-can-code","text":"In the main.c , you should see 6 TODOs. We will walk through each of them. As a reminder, when you are writing code, make sure to write within the /* USER CODE */ tags. This will ensure that your code is not overwritten when you regenerate the code.","title":"4. Writing the CAN code"},{"location":"getting-started/starter/servo/part2-can/#todo-1-create-the-necessary-variables-to-send-a-can-message","text":"In order to send a CAN message, we need to create two objects: The message header The message data The message header is an object of type FDCAN_TxHeaderTypeDef . This will store information about the CAN message we are sending, such as the identifier, the data length, the frame format, etc. The message data is an array of bytes that will be sent in the CAN message. In this project, we will only be sending one byte of data, which will represent the angle the servo should be set to. To declare a byte of data, you can use the uint8_t type.","title":"TODO 1: Create the necessary variables to send a CAN message"},{"location":"getting-started/starter/servo/part2-can/#todo-2-start-the-can-peripheral","text":"We'll notice that there towards the top of the main.c file, there is the following object: FDCAN_HandleTypeDef hfdcan1; This is the handle for the FDCAN peripheral. We will need to initialize the FDCAN peripheral using the HAL_FDCAN_Start function. This function takes in the handle for the FDCAN peripheral. We can use the following code snippet to start the FDCAN peripheral: HAL_FDCAN_Start(&hfdcan1);","title":"TODO 2: Start the CAN peripheral"},{"location":"getting-started/starter/servo/part2-can/#todo-3-form-the-can-message-header","text":"In this step, we will need to fill out the FDCAN_TxHeaderTypeDef object that we created in TODO 1 with the necessary information to send a CAN message. Below is the structure of the FDCAN_TxHeaderTypeDef object: /** * @brief FDCAN Tx header structure definition */ typedef struct { uint32_t Identifier; /*!< Specifies the identifier. This parameter must be a number between: - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID */ uint32_t IdType; /*!< Specifies the identifier type for the message that will be transmitted. This parameter can be a value of @ref FDCAN_id_type */ uint32_t TxFrameType; /*!< Specifies the frame type of the message that will be transmitted. This parameter can be a value of @ref FDCAN_frame_type */ uint32_t DataLength; /*!< Specifies the length of the frame that will be transmitted. This parameter can be a value of @ref FDCAN_data_length_code */ uint32_t ErrorStateIndicator; /*!< Specifies the error state indicator. This parameter can be a value of @ref FDCAN_error_state_indicator */ uint32_t BitRateSwitch; /*!< Specifies whether the Tx frame will be transmitted with or without bit rate switching. This parameter can be a value of @ref FDCAN_bit_rate_switching */ uint32_t FDFormat; /*!< Specifies whether the Tx frame will be transmitted in classic or FD format. This parameter can be a value of @ref FDCAN_format */ uint32_t TxEventFifoControl; /*!< Specifies the event FIFO control. This parameter can be a value of @ref FDCAN_EFC */ uint32_t MessageMarker; /*!< Specifies the message marker to be copied into Tx Event FIFO element for identification of Tx message status. This parameter must be a number between 0 and 0xFF */ } FDCAN_TxHeaderTypeDef; The following code snippet shows how to fill out the FDCAN_TxHeaderTypeDef object to send a Classic CAN (CAN 2.0) message with a standard identifier of 88 and a data length of 8 bytes: // In TODO 1: // FDCAN_TxHeaderTypeDef TxHeader; TxHeader.Identifier = 88; TxHeader.IdType = FDCAN_STANDARD_ID; TxHeader.TxFrameType = FDCAN_DATA_FRAME; TxHeader.DataLength = FDCAN_DLC_BYTES_8; TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE; TxHeader.BitRateSwitch = FDCAN_BRS_OFF; TxHeader.FDFormat = FDCAN_CLASSIC_CAN; TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS; TxHeader.MessageMarker = 0; We will need to fill out the FDCAN_TxHeaderTypeDef object with the correct values for the CAN message you are trying to send. Refer back to 2. Understanding our CAN bus for this information.","title":"TODO 3: Form the CAN message header"},{"location":"getting-started/starter/servo/part2-can/#todo-4-6-send-a-can-message-to-rotate-the-servo","text":"Now that we have the CAN message header for all the messages we want to send, we can send the message using the HAL_FDCAN_AddMessageToTxFifoQ function. This function takes in the handle for the FDCAN peripheral, the message header, and the message data. Here is an example of how to send a CAN message to turn the servo to 45 degrees: // In TODO 1: // uint8_t TxData[1]; TxData[0] = 45; HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &TxHeader, TxData);","title":"TODO 4-6: Send a CAN message to rotate the servo"},{"location":"getting-started/starter/servo/part2-can/#5-testing-the-project","text":"We will now connect to the CAN bus that the other Nucleo board is connected to. We will be using the MCP2551 CAN transceiver to connect to the CAN bus. For access to the CAN bus, please ask an ESW lead. The CAN TX and RX pins on the STM32G431RB Nucleo can be found in the .ioc file. These pins should connect to the CAN TX and RX pins on the MCP2551 CAN transceiver. The CANH and CANL pins on the MCP2551 should connect to the CANH and CANL pins on the CAN bus. We will now be able to test the project. To do this, we will need to build and flash the code onto the STM32G431RB Nucleo board. Once you have flashed the code, you should see the servo rotate to the angle specified in the CAN messages.","title":"5. Testing the project"},{"location":"getting-started/starter/temp-humidity/","text":"Temperature and Humidity Starter Project About The purpose of this starter project is to guide you through reading data from the AHT20 Temperature and Humidity Sensor using I2C with an STM32 Nucleo Hardware Nucleo STM32G431RB AHT20 Temperature and Humidity Sensor Lots of female-to-male, male-to-male, and female-to-female wires! 1 USB A to mini B cable Breadboard Data Sheets and Pinouts AHT20 Sensor datasheet Nucleo STM32G431RB User Manual (pinout on page 29) Hexadecimal Hexadecimal is a numbering system which uses base-16. Unlike our usual base-10 decimal system (0123456789) or the base-2 binary system (01), hexadecimal has a total of 16 different digits (0123456789ABCDEF). We tend to use hexadecimal to express our binary-based ideas because it is easier to read and easy to convert to and from binary. Each hexadecimal digit is equal to four bits (binary digits). For example, Hex number 0xA is equivalent to binary number 0b1010, or decimal number 10. Because of this a byte can be represented by two hexadecimal digits (8 bits). Most numbers in the datasheet will be expressed in hexadecimal, especially when referring to addresses, memory locations, or registers. Here is a good online converter for going from binary to hex. Go ahead and use that calculator to convert the binary string to hex. A thing to note about hex values is that they are commonly prefixed by 0x . What are LSB and MSB? We may have to work with data values which are many bytes long. However, sometimes we are restricted to working with just one byte at a time. Therefore, we split large data values into \"most significant\" and \"least significant\" bytes. The AHT20 returns temperature and humidity values as 2.5 byte raw values. However, each byte is sent individually, so to get the full raw temperature and humidity values we will need to combine the 2.5 bytes using the logical left shift operator (<<). As a decimal analogy to this, imagine you have the number 2048. In MSB/LSB format it could be split up as 20 and 48. In order to combine the two correctly, you have to shift 20 over 2 decimal places (multiply by 10^2) and then add it to 48. When it comes to retrieving and combining the data of the 2.5 bytes, the idea is the same. Splitting the data to be sent into multiple registers allows for higher precision data to be sent. More in depth info . What is I2C? I2C offers two-way communication between a device such as the AHT20 (slave) and the Nucleo (master). Notice the SDA (Serial Data) and SCL (Serial Clock) pins on both the AHT20 sensor and the Nucleo. I2C relies on the clock line (SCL) to keep time between the devices connected so that they can communicate at the same rate. The data line (SDA) is a shared data line between the devices. Each device enabled with I2C also has a 7 bit address. Try to find the address for the AHT20 sensor in the datasheet . Read this if you want to learn more about I2C. What is an I2C address? A master device can have multiple slaves. Therefore, each slave device needs a distinct address which the master can use to select the correct device to communicate with over the I2C bus. The AHT20 I2C address we will need to write to and read from is found here . What are Callbacks? A callback is a function that is called automatically when an operation finishes (like I2C read and write operations). We don't need to make these function calls ourselves, the microcontroller instead does it for us. We will use I2C transmit and recieve callbacks to handle communicating with the AHT20 sensor without having to block other code from finishing while we wait for transmits/recieves to finish. Starter code If you already cloned mrover-esw for the other starter projects , you do not need to do it again for the temperature and humidity sensor. To get the starter code, open up a new terminal window, clone the mrover-esw repository, and make a tutorial branch for yourself\\ $ git clone https://github.com/umrover/mrover-esw (if not already cloned)\\ $ cd mrover-esw \\ $ git checkout -b starter/<name> Open up the Cube IDE project by opening the folder and double clicking on the .project file. Make sure that you already have Cube IDE installed. Wiring and Set up Notice that the AHT20 sensor has 4 pins: VIN (voltage input), GND (ground), SCL (I2C clock line), and SDA (I2C data line). We will use the jumper wires and breadboard from the hardware step to make appropriate connections to all four pins. To wire the sensor connect the VIN pin on the AHT20 sensor to the 3.3V pin on the nucleo and the GND pin on the AHT20 sensor to the GND pin on the nucleo. To use I2C we will need to connect the clock and data pins of the AHT20 sensor to the clock and data pins on the nucleo that we configured in our .ioc file. To see which pins we are using for I2C on the nucleo open the .ioc file and search for the pins set to I2C3_SCL and I2C3_SDA. Finally, make connections to the pins corresponding to I2C3_SCL and I2C3_SDA on the nucleo using the pinout found on page 29 here . Getting Started Notice that the starter file for the project already contains multiple variable definitions. To begin set the value of the TEMP_HUM_ADDRESS constant to the AHT20 address found earlier. We will use this constant throughout our code when interacting with the sensor over I2C. Also notice the init() function which is called once, and has the job of pointing the \"i2c\" pointer to the hi2c3 object and also calling the eventLoop() function, which is the infinite loop that we will use to constantly send and receive data from the AHT20 sensor. The process for receiving data from the AHT20 sensor can be broken into 3 main steps: - Transmit a command (found in the datasheet) to the sensor to start a measurement, using the HAL_I2C_Master_Transmit_IT function. - Implement the HAL_I2C_MasterTxCpltCallback callback function, which will be called when the sensor has finished measuring and storing the new temperature and humidity values. We need these values so you will need to request them using the HAL_I2C_Master_Receive_IT function and by providing the buffer defined earlier in the code. The buffer will be the location in which the received bytes will be stored. - Finally implement the HAL_I2C_MasterRxCpltCallback callback function, which will be called when the sensor has sent us the raw values and the buffer is populated. You will then need to convert the raw values to the actual temperature and humidity values found in the datasheet. Important Notes and Tips Define functions for transmitting, receiving, and converting values to and from the AHT20 sensor outside of the eventLoop and I2C callback functions and then call these functions when necessary. As described in the datasheet the AHT20 requires a delay after powering on the sensor. Find the delay and add it to the start of your code. The address parameters of the HAL I2C receive and transmit functions will need to be provided with 8 bits, bits 1-7 will be the AHT20's ID and bit 0 represents whether you are writing/reading (0/1) to the sensor. You can accomplish this using the logical left shift operator (<<) and the bitwise or operator (|). When converting the raw values from the buffer to the actual sensor values use the datasheet to determine which bytes from the buffer correspond to temperature/humidity and use the logical left shift operator (<<) to combine them into a single value. Then use the conversion formula from the datasheet to find the actual temperature and humidity values. Testing In this tutorial we do not print out data anywhere. Because of this you will have to use the debugger to view the temperature and humidity measurements you get from the sensor. This is good practice for what you may expect to see in the future. Debugging in Cube IDE Make sure that your Nucleo is properly connected to your computer and that you can build your project. Click on Run -> Debug As -> 1 STM32 C/C++ Application. On the following screen, you can just press OK. If your device is unable to detect the Nucleo connected to it, you may see the following screen. Retry the previous steps and if that does not work, then either double check your connections, or seek a new Nucleo board. In the future, you may be able to get away with just clicking on Run -> Debug, or using the keyboard shortcut F11. This does not work the first time if you have never clicked on the Debug As button. Now that you're in the debug mode, you may set breakpoints and run through your code or pause at any given moment. When paused, we can also see the values of certain variables. We will use this feature to view if the data we are reading for our temperature and humidity sensor is reasonable. Congratulations! You have completed the temperature and humidity sensor starter project! Contact one the ESW leads for further instructions.","title":"Temp-Humidity"},{"location":"getting-started/starter/temp-humidity/#temperature-and-humidity-starter-project","text":"","title":"Temperature and Humidity Starter Project"},{"location":"getting-started/starter/temp-humidity/#about","text":"The purpose of this starter project is to guide you through reading data from the AHT20 Temperature and Humidity Sensor using I2C with an STM32 Nucleo","title":"About"},{"location":"getting-started/starter/temp-humidity/#hardware","text":"Nucleo STM32G431RB AHT20 Temperature and Humidity Sensor Lots of female-to-male, male-to-male, and female-to-female wires! 1 USB A to mini B cable Breadboard","title":"Hardware"},{"location":"getting-started/starter/temp-humidity/#data-sheets-and-pinouts","text":"AHT20 Sensor datasheet Nucleo STM32G431RB User Manual (pinout on page 29)","title":"Data Sheets and Pinouts"},{"location":"getting-started/starter/temp-humidity/#hexadecimal","text":"Hexadecimal is a numbering system which uses base-16. Unlike our usual base-10 decimal system (0123456789) or the base-2 binary system (01), hexadecimal has a total of 16 different digits (0123456789ABCDEF). We tend to use hexadecimal to express our binary-based ideas because it is easier to read and easy to convert to and from binary. Each hexadecimal digit is equal to four bits (binary digits). For example, Hex number 0xA is equivalent to binary number 0b1010, or decimal number 10. Because of this a byte can be represented by two hexadecimal digits (8 bits). Most numbers in the datasheet will be expressed in hexadecimal, especially when referring to addresses, memory locations, or registers. Here is a good online converter for going from binary to hex. Go ahead and use that calculator to convert the binary string to hex. A thing to note about hex values is that they are commonly prefixed by 0x .","title":"Hexadecimal"},{"location":"getting-started/starter/temp-humidity/#what-are-lsb-and-msb","text":"We may have to work with data values which are many bytes long. However, sometimes we are restricted to working with just one byte at a time. Therefore, we split large data values into \"most significant\" and \"least significant\" bytes. The AHT20 returns temperature and humidity values as 2.5 byte raw values. However, each byte is sent individually, so to get the full raw temperature and humidity values we will need to combine the 2.5 bytes using the logical left shift operator (<<). As a decimal analogy to this, imagine you have the number 2048. In MSB/LSB format it could be split up as 20 and 48. In order to combine the two correctly, you have to shift 20 over 2 decimal places (multiply by 10^2) and then add it to 48. When it comes to retrieving and combining the data of the 2.5 bytes, the idea is the same. Splitting the data to be sent into multiple registers allows for higher precision data to be sent. More in depth info .","title":"What are LSB and MSB?"},{"location":"getting-started/starter/temp-humidity/#what-is-i2c","text":"I2C offers two-way communication between a device such as the AHT20 (slave) and the Nucleo (master). Notice the SDA (Serial Data) and SCL (Serial Clock) pins on both the AHT20 sensor and the Nucleo. I2C relies on the clock line (SCL) to keep time between the devices connected so that they can communicate at the same rate. The data line (SDA) is a shared data line between the devices. Each device enabled with I2C also has a 7 bit address. Try to find the address for the AHT20 sensor in the datasheet . Read this if you want to learn more about I2C.","title":"What is I2C?"},{"location":"getting-started/starter/temp-humidity/#what-is-an-i2c-address","text":"A master device can have multiple slaves. Therefore, each slave device needs a distinct address which the master can use to select the correct device to communicate with over the I2C bus. The AHT20 I2C address we will need to write to and read from is found here .","title":"What is an I2C address?"},{"location":"getting-started/starter/temp-humidity/#what-are-callbacks","text":"A callback is a function that is called automatically when an operation finishes (like I2C read and write operations). We don't need to make these function calls ourselves, the microcontroller instead does it for us. We will use I2C transmit and recieve callbacks to handle communicating with the AHT20 sensor without having to block other code from finishing while we wait for transmits/recieves to finish.","title":"What are Callbacks?"},{"location":"getting-started/starter/temp-humidity/#starter-code","text":"If you already cloned mrover-esw for the other starter projects , you do not need to do it again for the temperature and humidity sensor. To get the starter code, open up a new terminal window, clone the mrover-esw repository, and make a tutorial branch for yourself\\ $ git clone https://github.com/umrover/mrover-esw (if not already cloned)\\ $ cd mrover-esw \\ $ git checkout -b starter/<name> Open up the Cube IDE project by opening the folder and double clicking on the .project file. Make sure that you already have Cube IDE installed.","title":"Starter code"},{"location":"getting-started/starter/temp-humidity/#wiring-and-set-up","text":"Notice that the AHT20 sensor has 4 pins: VIN (voltage input), GND (ground), SCL (I2C clock line), and SDA (I2C data line). We will use the jumper wires and breadboard from the hardware step to make appropriate connections to all four pins. To wire the sensor connect the VIN pin on the AHT20 sensor to the 3.3V pin on the nucleo and the GND pin on the AHT20 sensor to the GND pin on the nucleo. To use I2C we will need to connect the clock and data pins of the AHT20 sensor to the clock and data pins on the nucleo that we configured in our .ioc file. To see which pins we are using for I2C on the nucleo open the .ioc file and search for the pins set to I2C3_SCL and I2C3_SDA. Finally, make connections to the pins corresponding to I2C3_SCL and I2C3_SDA on the nucleo using the pinout found on page 29 here .","title":"Wiring and Set up"},{"location":"getting-started/starter/temp-humidity/#getting-started","text":"Notice that the starter file for the project already contains multiple variable definitions. To begin set the value of the TEMP_HUM_ADDRESS constant to the AHT20 address found earlier. We will use this constant throughout our code when interacting with the sensor over I2C. Also notice the init() function which is called once, and has the job of pointing the \"i2c\" pointer to the hi2c3 object and also calling the eventLoop() function, which is the infinite loop that we will use to constantly send and receive data from the AHT20 sensor. The process for receiving data from the AHT20 sensor can be broken into 3 main steps: - Transmit a command (found in the datasheet) to the sensor to start a measurement, using the HAL_I2C_Master_Transmit_IT function. - Implement the HAL_I2C_MasterTxCpltCallback callback function, which will be called when the sensor has finished measuring and storing the new temperature and humidity values. We need these values so you will need to request them using the HAL_I2C_Master_Receive_IT function and by providing the buffer defined earlier in the code. The buffer will be the location in which the received bytes will be stored. - Finally implement the HAL_I2C_MasterRxCpltCallback callback function, which will be called when the sensor has sent us the raw values and the buffer is populated. You will then need to convert the raw values to the actual temperature and humidity values found in the datasheet.","title":"Getting Started"},{"location":"getting-started/starter/temp-humidity/#important-notes-and-tips","text":"Define functions for transmitting, receiving, and converting values to and from the AHT20 sensor outside of the eventLoop and I2C callback functions and then call these functions when necessary. As described in the datasheet the AHT20 requires a delay after powering on the sensor. Find the delay and add it to the start of your code. The address parameters of the HAL I2C receive and transmit functions will need to be provided with 8 bits, bits 1-7 will be the AHT20's ID and bit 0 represents whether you are writing/reading (0/1) to the sensor. You can accomplish this using the logical left shift operator (<<) and the bitwise or operator (|). When converting the raw values from the buffer to the actual sensor values use the datasheet to determine which bytes from the buffer correspond to temperature/humidity and use the logical left shift operator (<<) to combine them into a single value. Then use the conversion formula from the datasheet to find the actual temperature and humidity values.","title":"Important Notes and Tips"},{"location":"getting-started/starter/temp-humidity/#testing","text":"In this tutorial we do not print out data anywhere. Because of this you will have to use the debugger to view the temperature and humidity measurements you get from the sensor. This is good practice for what you may expect to see in the future.","title":"Testing"},{"location":"getting-started/starter/temp-humidity/#debugging-in-cube-ide","text":"Make sure that your Nucleo is properly connected to your computer and that you can build your project. Click on Run -> Debug As -> 1 STM32 C/C++ Application. On the following screen, you can just press OK. If your device is unable to detect the Nucleo connected to it, you may see the following screen. Retry the previous steps and if that does not work, then either double check your connections, or seek a new Nucleo board. In the future, you may be able to get away with just clicking on Run -> Debug, or using the keyboard shortcut F11. This does not work the first time if you have never clicked on the Debug As button. Now that you're in the debug mode, you may set breakpoints and run through your code or pause at any given moment. When paused, we can also see the values of certain variables. We will use this feature to view if the data we are reading for our temperature and humidity sensor is reasonable.","title":"Debugging in Cube IDE"},{"location":"getting-started/starter/temp-humidity/#congratulations","text":"You have completed the temperature and humidity sensor starter project! Contact one the ESW leads for further instructions.","title":"Congratulations!"},{"location":"getting-started/stm32cubeide/","text":"STM32CubeIDE About STM32CubeIDE allows the user to write, compile, and flash code to the STM32 microcontroller! The IDE is based on the Eclipse framework and contains the GCC compiler and GDB debugging tool for in program compilation and debugging. The IDE also has flashing functionality for easy and quick programming of the STM32 microcontroller. The IDE provides a very powerful interface for automatic code generation, allowing the user to initialize an entire module with a few clicks of a button, and have that code show up automatically in the main file. Downloading and Installing Download Go to the CubeIDE download page and scroll down to \"Get Software.\" For this walkthrough, we will be using the Debian Linux installer for UBUNTU USERS. Click on \"Select Version\", then select the newest version for the correct OS you are running!!! Click on Accept for the License Agreement pop up. You will then be prompted to log in, create an account, or continue as a guest. You will need a MyST account in the future, so it is best to create one now. You may use any email address. After logging in and being brought back to the download page, scroll back down to \"Get Software\". It may take a while for the \"Get Software\" section to load. Download the newest version of the OS you are running. Again, this tutorial will be using the Debian Linux installer. Install Note : This install guide is for Linux . Please make sure to install the correct version for the OS you are running. 1. Open a new terminal ( guide ). 2. The downloaded installer zip file should be in your Downloads folder. You can navigate to this folder by entering the following command in your terminal: cd ~/Downloads 3. You should now be able to see the installer .zip file, if you run the following command: ls 4. To unzip the installer, run the following command (this may take a second): unzip <zip_file_name> For example: unzip en.st-stm32cubeide_1.16.0_21983_20240628_1741_amd64.deb_bundle.sh.zip 5. You should now be able to see the installer .zip file along with the installer .sh file if you repeat the ls command in step 3. 6. Run the installer by running the following (you may be prompted to enter your password): sudo sh <sh_file_name> For example: sudo sh st-stm32cubeide_1.16.0_21983_20240628_1741_amd64.deb_bundle.sh 7. Accept the installer license agreement by entering s until you are given the option to accept. Then, enter y and then the Enter key. 8. Install the Segger J-Link udev rules by clicking y and then the Enter key. 9. Accept the Segger J-Link license agreement by entering s until you are given the option to accept. Then, click y and then the Enter key. 10. It may take a while to install. You are done once you have seen the following: STM32CubeIDE installed successfully 11. You should now be able to launch STM32CubeIDE from the Ubuntu Applications menu ( guide ). Creating a New Project This quick guide will teach you how to make a new project for your STM32G431RB Nucleo board that you will be developing on. Prerequisites STM32CubeIDE installed Guide Open STM32CubeIDE, select the desired workspace, and click Launch (the default is fine for now). In the top left, go to File \u2192 New \u2192 STM32 Project . You may experience some lag after the previous step. Eventually, you will be prompted with the following window: At the top, select the Board Selector option. Then on the left, in the text box next to Commercial Part Number , type G431RB . There should only be one option in the Boards List Section, click that and press Next : Now you will be prompted with the following window: Here you can name your project whatever you want, but we can just call it \"tutorial\". Leave everything else as default and click Finish. You will then be prompted with this window to configure this board. Make sure to uncheck all the boxes by clicking Unselect All . Then select OK . It may also ask about changing perspective. Here, it comes down to preference, but you can just click Yes . You should now see the following screen, which means that you have successfully created the project! Notice the graphical interface of the chip on the right (which we may call the .ioc file) and the files on the left that fall under the tutorial project (most importantly, Src/main.c and tutorial.ioc ). Cool things to know is the graphical interface is used to make changes to the chip settings. If changes are made, then once the project is saved, code will be auto-generated for the user. The main.c file is where you will want to write your code. Congratulations! You have successfully created a new project in CubeIDE! Opening an Existing Project This quick guide will teach you how to open an existing STM32 project in your STM32CubeIDE workspace. Prerequisites STM32CubeIDE installed Any existing STM32 project downloaded Guide Open up STM32CubeIDE. Then, select the desired workspace that you want to open the project in and click Launch . In the top left, go to File \u2192 Open Projects from File System . Open the project directory in Import source . Click Finish . Congratulations! You have successfully opened an existing project in CubeIDE! Note: Your project files will remain in the original directory that you opened and any changes you make in STM32CubeIDE will reflect in the original directory. All that you have done is added the project to the workspace, allowing you to open it in STM32CubeIDE.","title":"STM32CubeIDE"},{"location":"getting-started/stm32cubeide/#stm32cubeide","text":"","title":"STM32CubeIDE"},{"location":"getting-started/stm32cubeide/#about","text":"STM32CubeIDE allows the user to write, compile, and flash code to the STM32 microcontroller! The IDE is based on the Eclipse framework and contains the GCC compiler and GDB debugging tool for in program compilation and debugging. The IDE also has flashing functionality for easy and quick programming of the STM32 microcontroller. The IDE provides a very powerful interface for automatic code generation, allowing the user to initialize an entire module with a few clicks of a button, and have that code show up automatically in the main file.","title":"About"},{"location":"getting-started/stm32cubeide/#downloading-and-installing","text":"","title":"Downloading and Installing"},{"location":"getting-started/stm32cubeide/#download","text":"Go to the CubeIDE download page and scroll down to \"Get Software.\" For this walkthrough, we will be using the Debian Linux installer for UBUNTU USERS. Click on \"Select Version\", then select the newest version for the correct OS you are running!!! Click on Accept for the License Agreement pop up. You will then be prompted to log in, create an account, or continue as a guest. You will need a MyST account in the future, so it is best to create one now. You may use any email address. After logging in and being brought back to the download page, scroll back down to \"Get Software\". It may take a while for the \"Get Software\" section to load. Download the newest version of the OS you are running. Again, this tutorial will be using the Debian Linux installer.","title":"Download"},{"location":"getting-started/stm32cubeide/#install","text":"Note : This install guide is for Linux . Please make sure to install the correct version for the OS you are running. 1. Open a new terminal ( guide ). 2. The downloaded installer zip file should be in your Downloads folder. You can navigate to this folder by entering the following command in your terminal: cd ~/Downloads 3. You should now be able to see the installer .zip file, if you run the following command: ls 4. To unzip the installer, run the following command (this may take a second): unzip <zip_file_name> For example: unzip en.st-stm32cubeide_1.16.0_21983_20240628_1741_amd64.deb_bundle.sh.zip 5. You should now be able to see the installer .zip file along with the installer .sh file if you repeat the ls command in step 3. 6. Run the installer by running the following (you may be prompted to enter your password): sudo sh <sh_file_name> For example: sudo sh st-stm32cubeide_1.16.0_21983_20240628_1741_amd64.deb_bundle.sh 7. Accept the installer license agreement by entering s until you are given the option to accept. Then, enter y and then the Enter key. 8. Install the Segger J-Link udev rules by clicking y and then the Enter key. 9. Accept the Segger J-Link license agreement by entering s until you are given the option to accept. Then, click y and then the Enter key. 10. It may take a while to install. You are done once you have seen the following: STM32CubeIDE installed successfully 11. You should now be able to launch STM32CubeIDE from the Ubuntu Applications menu ( guide ).","title":"Install"},{"location":"getting-started/stm32cubeide/#creating-a-new-project","text":"This quick guide will teach you how to make a new project for your STM32G431RB Nucleo board that you will be developing on.","title":"Creating a New Project"},{"location":"getting-started/stm32cubeide/#prerequisites","text":"STM32CubeIDE installed","title":"Prerequisites"},{"location":"getting-started/stm32cubeide/#guide","text":"Open STM32CubeIDE, select the desired workspace, and click Launch (the default is fine for now). In the top left, go to File \u2192 New \u2192 STM32 Project . You may experience some lag after the previous step. Eventually, you will be prompted with the following window: At the top, select the Board Selector option. Then on the left, in the text box next to Commercial Part Number , type G431RB . There should only be one option in the Boards List Section, click that and press Next : Now you will be prompted with the following window: Here you can name your project whatever you want, but we can just call it \"tutorial\". Leave everything else as default and click Finish. You will then be prompted with this window to configure this board. Make sure to uncheck all the boxes by clicking Unselect All . Then select OK . It may also ask about changing perspective. Here, it comes down to preference, but you can just click Yes . You should now see the following screen, which means that you have successfully created the project! Notice the graphical interface of the chip on the right (which we may call the .ioc file) and the files on the left that fall under the tutorial project (most importantly, Src/main.c and tutorial.ioc ). Cool things to know is the graphical interface is used to make changes to the chip settings. If changes are made, then once the project is saved, code will be auto-generated for the user. The main.c file is where you will want to write your code. Congratulations! You have successfully created a new project in CubeIDE!","title":"Guide"},{"location":"getting-started/stm32cubeide/#opening-an-existing-project","text":"This quick guide will teach you how to open an existing STM32 project in your STM32CubeIDE workspace.","title":"Opening an Existing Project"},{"location":"getting-started/stm32cubeide/#prerequisites_1","text":"STM32CubeIDE installed Any existing STM32 project downloaded","title":"Prerequisites"},{"location":"getting-started/stm32cubeide/#guide_1","text":"Open up STM32CubeIDE. Then, select the desired workspace that you want to open the project in and click Launch . In the top left, go to File \u2192 Open Projects from File System . Open the project directory in Import source . Click Finish . Congratulations! You have successfully opened an existing project in CubeIDE! Note: Your project files will remain in the original directory that you opened and any changes you make in STM32CubeIDE will reflect in the original directory. All that you have done is added the project to the workspace, allowing you to open it in STM32CubeIDE.","title":"Guide"},{"location":"headers/hardware/","text":"TODO: ADD DOXY TO FIRMWARE HEADER FILES","title":"hardware.hpp"},{"location":"headers/hardware/#todo-add-doxy-to-firmware-header-files","text":"","title":"TODO: ADD DOXY TO FIRMWARE HEADER FILES"},{"location":"info/brushed/","text":"Brushed DC Motors Our brushed motors are controlled with a custom PCB that we call the \"3BM\". This motor controller can control up to three brushed motors. It can support up to two limit switches per motor and a total of one absolute encoder and one quadrature encoder. We communicate with the board using CAN. The board communicates with the absolute encoder using I2C. Code Structure The driver code is in controller.cpp and the main motor control logic is in motor.hpp . Motor CAN IDs and the number of motors is configured in common.hpp . controller.cpp constructs up to three motors, initalizes the CAN bus, and starts the global timers. Architecture Below is a diagram of the 3BM architecture. Timer Overview The 3BM uses seven hardware timers: htim1 ( PWM_TIMER_[0,1,2] ): PWM timer for the three motors ( TIM_CHANNEL_[0,1,2] for motor [0,1,2], respectively) htim2 ( GENERIC_ELAPSED_TIMER ): Repeating count up timer where each tick is 0.001 ms (1000 ns). It used used by: The absolute and quadrature encoder to measure how much time has elapsed since the last reading in order to measure velocity The PIDF controller in order to measure the time elapsed since the last reading to update the \"D\" term htim4 ( QUADRATURE_TICK_TIMER ): Incremental encoder timer configured to read a two-phase quadrature encoder htim6 ( GLOBAL_UPDATE_TIMER ): 20 Hz timer which triggers a CAN FD transmit (sends motor state) htim15 , htim16 , htim17 ( RECEIVE_WATCHDOG_TIMER_[0,1,2] ): FDCAN watchdog timer that needs to be reset every time a message is received","title":"Brushed Motors"},{"location":"info/brushed/#brushed-dc-motors","text":"Our brushed motors are controlled with a custom PCB that we call the \"3BM\". This motor controller can control up to three brushed motors. It can support up to two limit switches per motor and a total of one absolute encoder and one quadrature encoder. We communicate with the board using CAN. The board communicates with the absolute encoder using I2C.","title":"Brushed DC Motors"},{"location":"info/brushed/#code-structure","text":"The driver code is in controller.cpp and the main motor control logic is in motor.hpp . Motor CAN IDs and the number of motors is configured in common.hpp . controller.cpp constructs up to three motors, initalizes the CAN bus, and starts the global timers.","title":"Code Structure"},{"location":"info/brushed/#architecture","text":"Below is a diagram of the 3BM architecture.","title":"Architecture"},{"location":"info/brushed/#timer-overview","text":"The 3BM uses seven hardware timers: htim1 ( PWM_TIMER_[0,1,2] ): PWM timer for the three motors ( TIM_CHANNEL_[0,1,2] for motor [0,1,2], respectively) htim2 ( GENERIC_ELAPSED_TIMER ): Repeating count up timer where each tick is 0.001 ms (1000 ns). It used used by: The absolute and quadrature encoder to measure how much time has elapsed since the last reading in order to measure velocity The PIDF controller in order to measure the time elapsed since the last reading to update the \"D\" term htim4 ( QUADRATURE_TICK_TIMER ): Incremental encoder timer configured to read a two-phase quadrature encoder htim6 ( GLOBAL_UPDATE_TIMER ): 20 Hz timer which triggers a CAN FD transmit (sends motor state) htim15 , htim16 , htim17 ( RECEIVE_WATCHDOG_TIMER_[0,1,2] ): FDCAN watchdog timer that needs to be reset every time a message is received","title":"Timer Overview"},{"location":"info/brushless/","text":"Brushless DC Motors","title":"Brushless Motors"},{"location":"info/brushless/#brushless-dc-motors","text":"","title":"Brushless DC Motors"},{"location":"info/cmake-tools/","text":"CMake + CubeMX/CubeCLT Toolchain Install CubeMX . This is the .ioc file editor. Install CubeCLT . This is the command-line toolset that contains all the software necessary to build and deploy the codebase. In order to use the scripts to build and flash, add all */bin directories from CubeCLT to $PATH . Install CubeMCUFinder . Install the corresponding extension for your editor. In each case, the extension will need to be provided the location to CubeMX and CubeCLT. CLion VS Code ./scripts/build.sh --src <PROJECT> will build the project ./scripts/flash.sh --src <PROJECT> will flash the project to the MCU connected to the STLINK Adding CMake Dependencies to Projects To add lib/ dependencies to a CubeMX project, add the following to CMakeLists.txt . # Add fwlib dependency add_subdirectory(../../lib fwlib) # Add linked libraries target_link_libraries(${CMAKE_PROJECT_NAME} stm32cubemx # Add user defined libraries stm32 units util )","title":"CMake Toolchain"},{"location":"info/cmake-tools/#cmake-cubemxcubeclt-toolchain","text":"Install CubeMX . This is the .ioc file editor. Install CubeCLT . This is the command-line toolset that contains all the software necessary to build and deploy the codebase. In order to use the scripts to build and flash, add all */bin directories from CubeCLT to $PATH . Install CubeMCUFinder . Install the corresponding extension for your editor. In each case, the extension will need to be provided the location to CubeMX and CubeCLT. CLion VS Code ./scripts/build.sh --src <PROJECT> will build the project ./scripts/flash.sh --src <PROJECT> will flash the project to the MCU connected to the STLINK","title":"CMake + CubeMX/CubeCLT Toolchain"},{"location":"info/cmake-tools/#adding-cmake-dependencies-to-projects","text":"To add lib/ dependencies to a CubeMX project, add the following to CMakeLists.txt . # Add fwlib dependency add_subdirectory(../../lib fwlib) # Add linked libraries target_link_libraries(${CMAKE_PROJECT_NAME} stm32cubemx # Add user defined libraries stm32 units util )","title":"Adding CMake Dependencies to Projects"},{"location":"info/nucleos/","text":"Nucleos Introduction A \u201cNucleo\u201d is a microcontroller evaluation board manufactured by STM32 to prototype with STM32\u2019s MCUs. Nucleos come with a removable ST-Link debugger/programmer integrated on the board, allowing firmware flashing and extensive debugging options through a simple USB connection. STM32 MCU have a wide range of hardware capabilities, with dedicated internal circuitry for I2C, SPI, UART, timers, and more. Firmware is typically written in C/C++ using STM32\u2019s extremely capable Hardware Abstraction Layer (HAL) libraries, and compiled in STM32\u2019s Cube IDE. MCU STM32 microcontrollers are organized into various categories, as shown. Each family of MCUs has dozens of models, each with a different feature set. The MCU\u2019s are a realization of ARM\u2019s Cortex M family of processors. Use the product selector on ST\u2019s website to find MCU\u2019s appropriate to your application. Nucleo STM32 Nucleos are evaluation boards available to prototype designs that employ STM32 MCUs. There are many models of Nucleos, named after the MCU installed, the physical form factor, and the flash memory size. All available Nucleo boards are shown below. Nucleos are often cheap (~$10 for a Nucleo-F303RE). The board breaks out all the MCU\u2019s available interfaces into header pins, while implementing most of the standard extraneous circuity (voltage regulators, oscillators, etc.) required by the MCU. Designed for prototyping/testing, Nucleos come with an ST-Link debugger/programmer module, which will automatically flash the MCU\u2019s firmware and allows the Cube IDE to debug code mid-execution. It is important to note that the essential component is the MCU itself - a Nucleo is just a helpful breakout board that ST has provided for select MCUs. Many topics discussed below, such as HAL/LL Libraries, interrupts, and interface peripherals, are elements of the MCU, not the Nucleo. A notable exception is the ST-Link programmer/debugger. This guide is very intentional with its use of the term \"MCU\" vs \"Nucleo\" Cube IDE ST\u2019s Cube IDE is built off of the Eclipse IDE. Upon creating a new \u201cSTM32 Project\u201d, the IDE will prompt the user to select a STM32 MCU. The IDE should automatically preload all relevant HAL libraries (discussed later) into the project workspace and generate the proper initialization code. A .ioc file is also generated, which when viewed in ST\u2019s custom \u201cDevice Configuation Tool\u201d perspective, allows the user to interactively control various features of the MCU. An example of this perspective is shown below. CubeIDE will use the settings specified in the .ioc file to automatically generate code for the STM32\u2019s firmware. STM32 processors typically use no operating system, and such behave much like an Arduino. At a basic level, their functionality is to run the main.c code that is flashed to their memory. Cube IDE will populate the main.c with the standard set of code necessary to get the MCU started. (RTOS is an option, but MRover firmware shouldn\u2019t be complex enough to necessitate RTOS) In reality, the STM32 MCU is flashed with a binary file containing machine code. CubeIDE uses g++ to compile C/C++ code, automatically passing g++ the appropriate instruction set (in this case, ARM Cortex instruction sets). ArduinoIDE does the same, using a C compiler to flash Arduinos with machine code. Developers typically never see the machine code, as the programming languages make a point of abstracting ISAs (instruction set architectures) away from the higher-level logic/structures programmers wish to deal with. Changing the MCU configuration in the device configuration tool should ask the developer whether or not to \u201cGenerate Code?\u201d Select yes, because this will prompt CubeIDE to regenerate the code necessary to set up the MCU as desired. CubeIDE often uses HAL functions or rarely LL functions to accomplish this, and will clearly mark all the pregenerated code with comments. STM32 Libraries HAL stands for Hardware Abstraction Layer. It is a library written by ST, available from Cube IDE, that provides interface functions that will control the STM32 MCU\u2019s hardware. By abstracting away the MCU model-specific details of hardware control, code using HAL functions should be easily ported between STM32 MCU\u2019s within the same lineup. For example, the entire STM32F4 series of MCU\u2019s are controlled using the same HAL library. HAL functions will do runtime checks for hardware faults. For example, if the I2C module of the MCU is locked in an inoperable state, the next I2C related HAL function will detect the issue. LL (Low-level) APIs are also available. They are a fast, light-weight, closer-to-hardware layer that developers can use to control the MCU hardware. They are, however, meant for embedded system experts, and it recommended the MCU hardware be entirely controlled by HAL functions. HAL and LL functions are documented thoroughly but shallowly. What this means is that the documentation definitely contains and explains every HAL/LL function that exists, but only brief, high-level explanations are provided. There is the assumption that STM32 developers understand coding principles such as callbacks and interrupts. There is also the expectation that STM32 developers are familiar with the interface peripherals they are controlling. ST-Link The USB connection on the Nucleo is actually a connection to the removable section of the board called the ST-Link. The ST-Link is able to flash firmware to the MCU, and control debugging related interface peripherals on the MCU. Removal of the ST-Link also removes the capability to do firmware flashing and live debugging through USB. ST-Link's are also available as a seperate piece of hardware, if a developer desires the ST-Link flashing/debugging experience with STM32 MCUs that aren't embedded into a Nucleo. ST has written the USB drivers for the ST-Link in a clever way. Upon connecting an ST-Link to a computer through USB, the ST-Link will appear as an external hard drive to the computer. The most basic way to flash an STM32 MCU with firmware is to copy the firmware compiled as a binary file into this \u201cexternal hard drive\u201d. The ST-Link will automatically flash the MCU with the binary, and the MCU begins executing the binary once complete. A more streamlined way to flash code to the STM32 MCU is through CubeIDE. There is, of course, the standard \u201cbuild\u201d button that most C++ IDE\u2019s have \u2013 responsible for compiling the main.c, main.h, other developer-written files, and necessary HAL functions into a single executable. CubeIDE also has a \u201cdebug\u201d button, which will build the executable and also send it directly to the ST-Link connected to the computer at the moment. Using this function will also connect the CubeIDE to all the ST-Link\u2019s debugging functionalities. This way, the MCU is controllable through CubeIDE with standard debugging steps. This includes pausing at breakpoints, stepping forward, stepping in, stepping out, continuing, etc\u2026 Debugging a STM32 MCU with active interface peripherals is dangerous, however \u2013 there is a good chance that the interface peripheral will enter faulty states because the MCU is not operating with normal execution flows. Note that there are two build options \u2013 debug and release. Debug builds are more helpful when debugging, and release builds are optimized for speed \u2013 up to several orders of magnitude faster. It is helpful to, in CubeIDE, follow these steps: 1. Open \"Properties\" from the \"Project\" dropdown menu at the top of the screen. 2. Open \"C/C++ Build\" > \"Settings\" from the lefthand navigation menu. 3. Select \"Debug\" for the Configuration option 4. Select the \"Tool Settings\" tab. 5. Select \"MCU Post build outputs\" from the lefthand navigation menu 6. Check the \"Convert to binary file\" option 7. Select \"Release\" for the Configuration option 8. Repeat steps 4-6 This will ensure CubeIDE always generates a single machine code binary for developer use within the project directory whenever the project is built. They will be located in the \"Debug\" or \"Release\" folders, depending on which type of build is used. The .bin file is a complete copy of the firmware for the STM32 MCU - it can be moved, saved, shared, as any normal file, as well as copied into the ST-Link's pretend \"External Drive\" to flash the STM32 MCU, independent of CubeIDE. Callbacks and Interrupts An interrupt is a signal that interrupts the natural flow of a program. This is typically done at a processor level, so interrupts can cause breakaways from practically anywhere in the code. When interrupts trigger, they force the processor to execute a separate segment of code. Only when that segment finishes, does the processor return to where it left off with the original program. HAL functions accomplish a lot of their functionality through callback functions. Callback functions are functions that are \u201cto be called back later\u201d. Interrupts generated by interface peripherals will typically call a callback function, pausing the main execution flow of the program to handle the event generated by the interrupt. For example, if a hardware counter unit on the STM32 MCU is configured to be a timer that generates an interrupt every second \u2013 every second, the hardware counter unit will signal to the processor to stop what it\u2019s doing (perhaps the processor is just waiting in a \u201cwhile true\u201d loop). The processor will enter the callback function labeled HAL_TIM_Callback(), expecting this function has been written to handle what should happen when this timer gives it\u2019s signal. Once that callback function finishes, the processor returns to its \u201cwhile true\u201d loop. Callback functions are \u201cweakly\u201d defined by the HAL \u2013 as soon as the developer redefines the function, the HAL callback function (which is just a placeholder and is functionally empty) is overwritten. This simple method of redefining HAL callback functions is an easy way for developers to write code that responds to events generated by the MCU\u2019s interface peripherals. The HAL documentation lists all the callback functions that can be overwritten. Interface Peripherals Interface peripherals refer broadly to the interfaces onboard the STM32 MCU. These are often implemented in hardware, not software. For example, below is a block diagram for the I2C interface on almost all STM32 F3 series MCU\u2019s. Hardware implemented interfaces have a number of advantages * They don't require processor cycles to operate * They use system clocks and their own state registers, isolating their performance from the rest of the MCU * They only trigger interrupts when meaningful events happen Controlling hardware interface peripherals typically involves writing to and reading from control registers. HAL/LL functions take care of this, abstracting the hardware away from the interfacing. Most interface peripherals can be controlled entirely through HAL functions, though the control registers can be read/written by a developer if necessary.","title":"Nucleo Information"},{"location":"info/nucleos/#nucleos-introduction","text":"A \u201cNucleo\u201d is a microcontroller evaluation board manufactured by STM32 to prototype with STM32\u2019s MCUs. Nucleos come with a removable ST-Link debugger/programmer integrated on the board, allowing firmware flashing and extensive debugging options through a simple USB connection. STM32 MCU have a wide range of hardware capabilities, with dedicated internal circuitry for I2C, SPI, UART, timers, and more. Firmware is typically written in C/C++ using STM32\u2019s extremely capable Hardware Abstraction Layer (HAL) libraries, and compiled in STM32\u2019s Cube IDE.","title":"Nucleos Introduction"},{"location":"info/nucleos/#mcu","text":"STM32 microcontrollers are organized into various categories, as shown. Each family of MCUs has dozens of models, each with a different feature set. The MCU\u2019s are a realization of ARM\u2019s Cortex M family of processors. Use the product selector on ST\u2019s website to find MCU\u2019s appropriate to your application.","title":"MCU"},{"location":"info/nucleos/#nucleo","text":"STM32 Nucleos are evaluation boards available to prototype designs that employ STM32 MCUs. There are many models of Nucleos, named after the MCU installed, the physical form factor, and the flash memory size. All available Nucleo boards are shown below. Nucleos are often cheap (~$10 for a Nucleo-F303RE). The board breaks out all the MCU\u2019s available interfaces into header pins, while implementing most of the standard extraneous circuity (voltage regulators, oscillators, etc.) required by the MCU. Designed for prototyping/testing, Nucleos come with an ST-Link debugger/programmer module, which will automatically flash the MCU\u2019s firmware and allows the Cube IDE to debug code mid-execution. It is important to note that the essential component is the MCU itself - a Nucleo is just a helpful breakout board that ST has provided for select MCUs. Many topics discussed below, such as HAL/LL Libraries, interrupts, and interface peripherals, are elements of the MCU, not the Nucleo. A notable exception is the ST-Link programmer/debugger. This guide is very intentional with its use of the term \"MCU\" vs \"Nucleo\"","title":"Nucleo"},{"location":"info/nucleos/#cube-ide","text":"ST\u2019s Cube IDE is built off of the Eclipse IDE. Upon creating a new \u201cSTM32 Project\u201d, the IDE will prompt the user to select a STM32 MCU. The IDE should automatically preload all relevant HAL libraries (discussed later) into the project workspace and generate the proper initialization code. A .ioc file is also generated, which when viewed in ST\u2019s custom \u201cDevice Configuation Tool\u201d perspective, allows the user to interactively control various features of the MCU. An example of this perspective is shown below. CubeIDE will use the settings specified in the .ioc file to automatically generate code for the STM32\u2019s firmware. STM32 processors typically use no operating system, and such behave much like an Arduino. At a basic level, their functionality is to run the main.c code that is flashed to their memory. Cube IDE will populate the main.c with the standard set of code necessary to get the MCU started. (RTOS is an option, but MRover firmware shouldn\u2019t be complex enough to necessitate RTOS) In reality, the STM32 MCU is flashed with a binary file containing machine code. CubeIDE uses g++ to compile C/C++ code, automatically passing g++ the appropriate instruction set (in this case, ARM Cortex instruction sets). ArduinoIDE does the same, using a C compiler to flash Arduinos with machine code. Developers typically never see the machine code, as the programming languages make a point of abstracting ISAs (instruction set architectures) away from the higher-level logic/structures programmers wish to deal with. Changing the MCU configuration in the device configuration tool should ask the developer whether or not to \u201cGenerate Code?\u201d Select yes, because this will prompt CubeIDE to regenerate the code necessary to set up the MCU as desired. CubeIDE often uses HAL functions or rarely LL functions to accomplish this, and will clearly mark all the pregenerated code with comments.","title":"Cube IDE"},{"location":"info/nucleos/#stm32-libraries","text":"HAL stands for Hardware Abstraction Layer. It is a library written by ST, available from Cube IDE, that provides interface functions that will control the STM32 MCU\u2019s hardware. By abstracting away the MCU model-specific details of hardware control, code using HAL functions should be easily ported between STM32 MCU\u2019s within the same lineup. For example, the entire STM32F4 series of MCU\u2019s are controlled using the same HAL library. HAL functions will do runtime checks for hardware faults. For example, if the I2C module of the MCU is locked in an inoperable state, the next I2C related HAL function will detect the issue. LL (Low-level) APIs are also available. They are a fast, light-weight, closer-to-hardware layer that developers can use to control the MCU hardware. They are, however, meant for embedded system experts, and it recommended the MCU hardware be entirely controlled by HAL functions. HAL and LL functions are documented thoroughly but shallowly. What this means is that the documentation definitely contains and explains every HAL/LL function that exists, but only brief, high-level explanations are provided. There is the assumption that STM32 developers understand coding principles such as callbacks and interrupts. There is also the expectation that STM32 developers are familiar with the interface peripherals they are controlling.","title":"STM32 Libraries"},{"location":"info/nucleos/#st-link","text":"The USB connection on the Nucleo is actually a connection to the removable section of the board called the ST-Link. The ST-Link is able to flash firmware to the MCU, and control debugging related interface peripherals on the MCU. Removal of the ST-Link also removes the capability to do firmware flashing and live debugging through USB. ST-Link's are also available as a seperate piece of hardware, if a developer desires the ST-Link flashing/debugging experience with STM32 MCUs that aren't embedded into a Nucleo. ST has written the USB drivers for the ST-Link in a clever way. Upon connecting an ST-Link to a computer through USB, the ST-Link will appear as an external hard drive to the computer. The most basic way to flash an STM32 MCU with firmware is to copy the firmware compiled as a binary file into this \u201cexternal hard drive\u201d. The ST-Link will automatically flash the MCU with the binary, and the MCU begins executing the binary once complete. A more streamlined way to flash code to the STM32 MCU is through CubeIDE. There is, of course, the standard \u201cbuild\u201d button that most C++ IDE\u2019s have \u2013 responsible for compiling the main.c, main.h, other developer-written files, and necessary HAL functions into a single executable. CubeIDE also has a \u201cdebug\u201d button, which will build the executable and also send it directly to the ST-Link connected to the computer at the moment. Using this function will also connect the CubeIDE to all the ST-Link\u2019s debugging functionalities. This way, the MCU is controllable through CubeIDE with standard debugging steps. This includes pausing at breakpoints, stepping forward, stepping in, stepping out, continuing, etc\u2026 Debugging a STM32 MCU with active interface peripherals is dangerous, however \u2013 there is a good chance that the interface peripheral will enter faulty states because the MCU is not operating with normal execution flows. Note that there are two build options \u2013 debug and release. Debug builds are more helpful when debugging, and release builds are optimized for speed \u2013 up to several orders of magnitude faster. It is helpful to, in CubeIDE, follow these steps: 1. Open \"Properties\" from the \"Project\" dropdown menu at the top of the screen. 2. Open \"C/C++ Build\" > \"Settings\" from the lefthand navigation menu. 3. Select \"Debug\" for the Configuration option 4. Select the \"Tool Settings\" tab. 5. Select \"MCU Post build outputs\" from the lefthand navigation menu 6. Check the \"Convert to binary file\" option 7. Select \"Release\" for the Configuration option 8. Repeat steps 4-6 This will ensure CubeIDE always generates a single machine code binary for developer use within the project directory whenever the project is built. They will be located in the \"Debug\" or \"Release\" folders, depending on which type of build is used. The .bin file is a complete copy of the firmware for the STM32 MCU - it can be moved, saved, shared, as any normal file, as well as copied into the ST-Link's pretend \"External Drive\" to flash the STM32 MCU, independent of CubeIDE.","title":"ST-Link"},{"location":"info/nucleos/#callbacks-and-interrupts","text":"An interrupt is a signal that interrupts the natural flow of a program. This is typically done at a processor level, so interrupts can cause breakaways from practically anywhere in the code. When interrupts trigger, they force the processor to execute a separate segment of code. Only when that segment finishes, does the processor return to where it left off with the original program. HAL functions accomplish a lot of their functionality through callback functions. Callback functions are functions that are \u201cto be called back later\u201d. Interrupts generated by interface peripherals will typically call a callback function, pausing the main execution flow of the program to handle the event generated by the interrupt. For example, if a hardware counter unit on the STM32 MCU is configured to be a timer that generates an interrupt every second \u2013 every second, the hardware counter unit will signal to the processor to stop what it\u2019s doing (perhaps the processor is just waiting in a \u201cwhile true\u201d loop). The processor will enter the callback function labeled HAL_TIM_Callback(), expecting this function has been written to handle what should happen when this timer gives it\u2019s signal. Once that callback function finishes, the processor returns to its \u201cwhile true\u201d loop. Callback functions are \u201cweakly\u201d defined by the HAL \u2013 as soon as the developer redefines the function, the HAL callback function (which is just a placeholder and is functionally empty) is overwritten. This simple method of redefining HAL callback functions is an easy way for developers to write code that responds to events generated by the MCU\u2019s interface peripherals. The HAL documentation lists all the callback functions that can be overwritten.","title":"Callbacks and Interrupts"},{"location":"info/nucleos/#interface-peripherals","text":"Interface peripherals refer broadly to the interfaces onboard the STM32 MCU. These are often implemented in hardware, not software. For example, below is a block diagram for the I2C interface on almost all STM32 F3 series MCU\u2019s. Hardware implemented interfaces have a number of advantages * They don't require processor cycles to operate * They use system clocks and their own state registers, isolating their performance from the rest of the MCU * They only trigger interrupts when meaningful events happen Controlling hardware interface peripherals typically involves writing to and reading from control registers. HAL/LL functions take care of this, abstracting the hardware away from the interfacing. Most interface peripherals can be controlled entirely through HAL functions, though the control registers can be read/written by a developer if necessary.","title":"Interface Peripherals"},{"location":"info/science/","text":"","title":"Science"},{"location":"info/stm32-boot/","text":"Ever wondered what that BOOT0 pin does in the STM32Cube IDE .ioc file or stm32 chip? Want to set the BOOT0 pin to an alternate function such as an I2C CLK? Here is what you need to know before doing so. The BOOT0 pin The BOOT0 pin only really matters for the first 4 clock cycles of the boot sequence after reset has been released. However, it decides where the chip will boot from: Main Flash, System Memory, or Embedded SRAM. (Maybe more or less options depending on the chip). By default, holding BOOT0 LOW will make the chip boot from the main flash - this is most likely where your code is. (When using CubeIDE, this is where it is typically flashed) If it is held high, for example let's say you are using it as an I2C CLK line with an external pull up resistor, this can cause make the chip boot from a region other than flash, which could lead to erratic behavior and floating pins. Alternate Boot Options As you can see from the table below, there are actually other ways of selecting the boot region. In fact, there is one option (row 2) that completely bypasses the BOOT0 pin in order to boot from flash. This is the option we want if using the BOOT0 pin for its alternate functions.\\ \\ STM32 G4 Series Manual Configuring Boot Options The following code was taken from a great stack overflow post . It configures the boot option register and sets nBOOT0 to 1 and nSWBOOT0 to 0. if ((FLASH->OPTR & FLASH_OPTR_nSWBOOT0_Msk) != 0x0 || ((FLASH->OPTR & FLASH_OPTR_nBOOT0_Msk) == 0x0)) { while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0x45670123; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0xCDEF89AB; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x08192A3B; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x4C5D6E7F; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->CR = FLASH->CR | FLASH_CR_OPTSTRT; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } } Here I explain it with some more detail.\\ while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } Polls the flash status register and waits until it is no longer busy. FLASH->KEYR = 0x45670123; \\ FLASH->KEYR = 0xCDEF89AB; Is the sequence of register writes needed to unlock flash for writing/reading. FLASH->OPTKEYR = 0x08192A3B; \\ FLASH->OPTKEYR = 0x4C5D6E7F; Is the sequence of register writes needed to unlock the Options register. FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; Sets nBOOT0 to 1 and nSWBOOT0 to 0. Other Resources STM has other methods of programming these option bits, including using HAL functions. See the following resources for more info. Also make sure to look at the STM reference manual for your particular chip regarding boot options.\\ How to program STM32 Option Bytes with the HAL API \\ What are option bytes in STM32 and how do I use them?","title":"STM32 Boot"},{"location":"info/stm32-boot/#ever-wondered-what-that-boot0-pin-does-in-the-stm32cube-ide-ioc-file-or-stm32-chip-want-to-set-the-boot0-pin-to-an-alternate-function-such-as-an-i2c-clk-here-is-what-you-need-to-know-before-doing-so","text":"","title":"Ever wondered what that BOOT0 pin does in the STM32Cube IDE .ioc file or stm32 chip? Want to set the BOOT0 pin to an alternate function such as an I2C CLK? Here is what you need to know before doing so."},{"location":"info/stm32-boot/#the-boot0-pin","text":"The BOOT0 pin only really matters for the first 4 clock cycles of the boot sequence after reset has been released. However, it decides where the chip will boot from: Main Flash, System Memory, or Embedded SRAM. (Maybe more or less options depending on the chip). By default, holding BOOT0 LOW will make the chip boot from the main flash - this is most likely where your code is. (When using CubeIDE, this is where it is typically flashed) If it is held high, for example let's say you are using it as an I2C CLK line with an external pull up resistor, this can cause make the chip boot from a region other than flash, which could lead to erratic behavior and floating pins.","title":"The BOOT0 pin"},{"location":"info/stm32-boot/#alternate-boot-options","text":"As you can see from the table below, there are actually other ways of selecting the boot region. In fact, there is one option (row 2) that completely bypasses the BOOT0 pin in order to boot from flash. This is the option we want if using the BOOT0 pin for its alternate functions.\\ \\ STM32 G4 Series Manual","title":"Alternate Boot Options"},{"location":"info/stm32-boot/#configuring-boot-options","text":"The following code was taken from a great stack overflow post . It configures the boot option register and sets nBOOT0 to 1 and nSWBOOT0 to 0. if ((FLASH->OPTR & FLASH_OPTR_nSWBOOT0_Msk) != 0x0 || ((FLASH->OPTR & FLASH_OPTR_nBOOT0_Msk) == 0x0)) { while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0x45670123; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0xCDEF89AB; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x08192A3B; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x4C5D6E7F; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->CR = FLASH->CR | FLASH_CR_OPTSTRT; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } } Here I explain it with some more detail.\\ while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } Polls the flash status register and waits until it is no longer busy. FLASH->KEYR = 0x45670123; \\ FLASH->KEYR = 0xCDEF89AB; Is the sequence of register writes needed to unlock flash for writing/reading. FLASH->OPTKEYR = 0x08192A3B; \\ FLASH->OPTKEYR = 0x4C5D6E7F; Is the sequence of register writes needed to unlock the Options register. FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; Sets nBOOT0 to 1 and nSWBOOT0 to 0.","title":"Configuring Boot Options"},{"location":"info/stm32-boot/#other-resources","text":"STM has other methods of programming these option bits, including using HAL functions. See the following resources for more info. Also make sure to look at the STM reference manual for your particular chip regarding boot options.\\ How to program STM32 Option Bytes with the HAL API \\ What are option bytes in STM32 and how do I use them?","title":"Other Resources"},{"location":"info/timers/","text":"Timers The following information is for STM32 timers. You will find similar concepts with different microcontrollers; however, the terminology and specifics may differ. Configuring a Timer There are three main parts that can control the behavior of a timer: Prescaler (PSC) Counter Period (also Auto-Reload Register, or ARR) Count & Compare Register (CCR) Let's break down each one: Prescaler (PSC) This value determines the frequency of the timer. The timer frequency is calculated by the following equation: Clock Frequency / (PSC+1) . For example, if our clock frequency is 72 MHz and we set PSC = 71, our timer will tick at a frequency of 1 MHz. Counter Period (Auto-Reload Register, or ARR) This defines the number of ticks in one period. The period is calculated by the following equation: (1 / Timer Frequency) * (ARR + 1) . For example, if our timer frequency is 1 MHz, then the timer will tick every 1000 ns. So, if we set the ARR = 4999, our period will be 0.005 seconds ( 1000 ns * (4999 + 1) = 0.005 s ). Count & Compare Register (CCR) This register holds a specific value that the timer tick counter is compared against. When the counter reaches the value in the CCR, an event is triggered, such as an interrupt or output signal change, which is commonly used for tasks like PWM generation or input capture. Use Cases Periodic Timer Input-Capture Output-Capture PWM What is PWM? PWM (pulse width modulation) is a digital signal that is set to high and low for a set amount of time to represent a percentage. Why do we use PWM? Over a wire, we can only send a value of 0 (low voltage) or 1 (high voltage). However, let's say that I want to control the percent brightness of an LED. How can I send this percentage (a value between 0 and 1) to the LED with just a wire that can only send 0 or 1? This is where PWM comes in. To send a value of 20% (0.20) using PWM, we first set a specified period . Then, for the first 20% of the period, we would set the wire to 1. For the rest of the period, we set the wire to 0. This gives us a duty cycle of 20%. Configuring a STM32 PWM timer For PWM, we will have to modify the PSC, ARR, and CCR registers. The PSC and ARR registers can be modified in the .ioc in order to set a constant period for the PWM signal. Then, in our code we can modify the CCR register in order to set different PWM signals. For normal PWM generation, the PWM signal will be set high in the beginning of the period. Then, when the timer counter goes above the value of CCR, the PWM signal will be set low. If you are still confused, here's a helpful slide deck that goes more in depth.","title":"Timers"},{"location":"info/timers/#timers","text":"The following information is for STM32 timers. You will find similar concepts with different microcontrollers; however, the terminology and specifics may differ.","title":"Timers"},{"location":"info/timers/#configuring-a-timer","text":"There are three main parts that can control the behavior of a timer: Prescaler (PSC) Counter Period (also Auto-Reload Register, or ARR) Count & Compare Register (CCR) Let's break down each one:","title":"Configuring a Timer"},{"location":"info/timers/#prescaler-psc","text":"This value determines the frequency of the timer. The timer frequency is calculated by the following equation: Clock Frequency / (PSC+1) . For example, if our clock frequency is 72 MHz and we set PSC = 71, our timer will tick at a frequency of 1 MHz.","title":"Prescaler (PSC)"},{"location":"info/timers/#counter-period-auto-reload-register-or-arr","text":"This defines the number of ticks in one period. The period is calculated by the following equation: (1 / Timer Frequency) * (ARR + 1) . For example, if our timer frequency is 1 MHz, then the timer will tick every 1000 ns. So, if we set the ARR = 4999, our period will be 0.005 seconds ( 1000 ns * (4999 + 1) = 0.005 s ).","title":"Counter Period (Auto-Reload Register, or ARR)"},{"location":"info/timers/#count-compare-register-ccr","text":"This register holds a specific value that the timer tick counter is compared against. When the counter reaches the value in the CCR, an event is triggered, such as an interrupt or output signal change, which is commonly used for tasks like PWM generation or input capture.","title":"Count &amp; Compare Register (CCR)"},{"location":"info/timers/#use-cases","text":"","title":"Use Cases"},{"location":"info/timers/#periodic-timer","text":"","title":"Periodic Timer"},{"location":"info/timers/#input-capture","text":"","title":"Input-Capture"},{"location":"info/timers/#output-capture","text":"","title":"Output-Capture"},{"location":"info/timers/#pwm","text":"","title":"PWM"},{"location":"info/timers/#what-is-pwm","text":"PWM (pulse width modulation) is a digital signal that is set to high and low for a set amount of time to represent a percentage.","title":"What is PWM?"},{"location":"info/timers/#why-do-we-use-pwm","text":"Over a wire, we can only send a value of 0 (low voltage) or 1 (high voltage). However, let's say that I want to control the percent brightness of an LED. How can I send this percentage (a value between 0 and 1) to the LED with just a wire that can only send 0 or 1? This is where PWM comes in. To send a value of 20% (0.20) using PWM, we first set a specified period . Then, for the first 20% of the period, we would set the wire to 1. For the rest of the period, we set the wire to 0. This gives us a duty cycle of 20%.","title":"Why do we use PWM?"},{"location":"info/timers/#configuring-a-stm32-pwm-timer","text":"For PWM, we will have to modify the PSC, ARR, and CCR registers. The PSC and ARR registers can be modified in the .ioc in order to set a constant period for the PWM signal. Then, in our code we can modify the CCR register in order to set different PWM signals. For normal PWM generation, the PWM signal will be set high in the beginning of the period. Then, when the timer counter goes above the value of CCR, the PWM signal will be set low. If you are still confused, here's a helpful slide deck that goes more in depth.","title":"Configuring a STM32 PWM timer"},{"location":"info/communication-protocols/","text":"Communication Protocols I2C I2C is a synchronous serial communication protocol that is commonly used in embedded systems. On MRover we often use I2C to interface with sensors. I2C has a single leader device and multiple follower devices (traditionally master and slave devices). An example of this is the science board being the leader and multiple sensors being the followers. The leader device controls the clock and initiates communication, while the followers respond when addressed. Each I2C device has a unique 7-bit address allowing for multiple devices to be placed on the same bus. I2C uses two wires, a clock line (SCL) and a data line (SDA). Both lines are open-drain and require pull-up resistors, meaning devices are only able to pull the line low and not drive it high, preventing possible damage. Below is a diagram of a sample I2C bus setup. How Communication Works Each transaction between the leader and a follower begins with a start condition and ends with a stop condition. Start Condition: occurs when the leader pulls SDA low while SCL is held high. Stop Condition: occurs when the leader releases SDA high while SCL is held high. After a start condition the leader sends a message over the bus consisting of: 7-bit address of follower Read/Write bit (0 = write, 1 = read) ACK bit (the addressed follower pulls SDA low to acknowledge its address was received) Then the actual data transfer begins, sending byte-by-byte with each byte followed by an ACK/NACK bit. After all data is sent the leader sends the stop condition and the bus waits for another transaction. CAN Controller Area Network (CAN) is a communication protocol that is used in many embedded systems, especially in industrial and automotive contexts where reliability is important. Devices speak to each other on a CAN bus, which is composed of two wires: CAN High (CANH) and CAN Low (CANL). CAN is a serial, multimaster, multicast protocol, which means that when the bus is free, any node can send a message (multimaster), and all nodes may receive and act on the message (multicast). The CAN protocol has evolved over time. It has three versions, introduced in chronological order: CAN 2.0A CAN 2.0B CAN FD Each version adds more features to the protocol while maintaining backwards compatibility. There are four types of CAN messages, or \u201cframes:\u201d the Data Frame, Remote Frame, Error Frame and Overload Frame. The data frame is the standard CAN message, broadcasting data from the transmitter to the other nodes on the bus. A remote frame is broadcast by a transmitter to request data from a specific node. An error frame may be transmitted by any node that detects a bus error. Overload frames are used to introduce additional delay between data or remote frames. The data frame is the most common frame type and is what this guide will cover. The data frame is made up of two important parts: the identifier and the data. The identifier can be used to determine the priority of the message. The lower the identifier, the higher the priority of the message. Furthermore, the identifier can be used to determine the source of the message, the destination of the message, or the type of message being sent. The data is the actual information being sent by the transmitter to the other nodes on the bus. The length of the identifier and data can vary depending on the version of CAN being used. There are many other fields in the data frame, but for the purposes of this guide, we will only cover the identifier and data. Refer to this document for a more in-depth look at the CAN protocol. CAN 2.0 CAN 2.0A is the original version of the CAN protocol. It supports an identifier up to 11 bits and data packets up to 8 bytes in length. CAN 2.0B is an extension of CAN 2.0A. It supports an identifier of either 11 bits or 29 bits and data packets up to 8 bytes in length. The 29-bit identifier allows for more unique identifiers to be used on the bus. All CAN 2.0 messages can be sent at a maximum rate of 1 Mbps. CAN FD CAN FD is the latest version of the CAN protocol. It supports an identifier of either 11 bits or 29 bits and data packets up to 64 bytes in length. The FD stands for Flexible Data-rate, which means that the data can be sent at a different rate than the rest of the message. This allows for a maximum data rate of 8 Mbps (although 5 Mbps is a more practical limit). The other parts of the message are sent at a maximum rate of 1 Mbps. The rate in which data is sent is often called the \"data rate,\" while the rate in which the rest of the message is sent is called the \"nominal rate.\" As a side note, although CAN FD can send up to 64 bytes of data in a single message, this does not mean that the data payload of the message can be any value up to 64 bytes. The data payload can be the following lengths: 0 to 8, 12, 16, 20, 24, 32, 48, or 64. CAN Bit Timing When using CAN, you will need to configure the bit timing. The bit timing determines how fast we send and receive messages on the CAN bus. The bit timing parameters are: Prescaler Sync Jump Width Time Seg 1 Time Seg 2 For CAN FD, data can be sent at a different rate than the rest of the message. So we end up with two different sets of bit timing parameters: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Data Prescaler Data Sync Jump Width Data Time Seg 1 Data Time Seg 2 For an in-depth guide on what these values mean, this video , although long, is very informative. CAN Bus As mentioned previously, the CAN bus is made up of two wires: CAN High (CANH) and CAN Low (CANL). Microcontrollers, however, do not have the capability to directly interface with the CAN bus. They require a CAN transceiver to convert the digital signals from the microcontroller to the analog signals on the CAN bus. The CAN transceiver also provides protection to the microcontroller from the high voltage on the CAN bus. This is why you will often see CAN TX and RX pins on a microcontroller, but no CANH or CANL pins. The TX and RX pins are connected to the CAN transceiver, which then connects to the CAN bus. Additionally, the CANH and CANL wires are connected to each other at the beginning and end of the bus. This is called termination. The termination is usually done with a 120\u03a9 resistor at each end of the bus. Termination is important because it helps to reduce reflections on the bus, which can cause data errors. Using the Kvaser Bit Timing Calculator We will go over finding these values for STM32 MCUs using an online tool provided by Kvaser. However, the process is similar for other microcontrollers and CAN hardware. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 For these values, we can use an online tool provided by Kvaser. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay We will go over finding these values for STM32 MCUs . The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 0.005 * 1,000,000 = 5,000 ppm The node delay is the max input/output propagation delay of our CAN transceiver. This value is dependent on the CAN transceiver that we are using. For the TCAN1042, the max propagation delay is 175 ns as shown below. Refer to the datasheet of the transceiver you are using to find this value. With these values, we can now use the Kvaser tool to calculate the bit timing values for our CAN bus. Scroll down to 1. Device Characteristics and make sure to delete the default device that has been added. Then, input the clock frequency, clock tolerance, and node delay. Click Add CAN Device . Then, scroll down to 2. Bitrates and input the desired bitrate for the CAN bus. Click Recalculate . Now in sections 3.1 and 3.2 , you can make changes to the nominal and data sample point percentages. Any percentage from 50% to 90% is acceptable. Many automotive applications use a value around 87.5% for nominal and around 70% - 80% for data. Finally, scroll down to 4. Individual Bus Timing Parameters and you will see the values for the bit timing parameters. You may also modify the prescaler (the data prescaler must be equal to 1 or 2).","title":"Communication Protocols"},{"location":"info/communication-protocols/#communication-protocols","text":"","title":"Communication Protocols"},{"location":"info/communication-protocols/#i2c","text":"I2C is a synchronous serial communication protocol that is commonly used in embedded systems. On MRover we often use I2C to interface with sensors. I2C has a single leader device and multiple follower devices (traditionally master and slave devices). An example of this is the science board being the leader and multiple sensors being the followers. The leader device controls the clock and initiates communication, while the followers respond when addressed. Each I2C device has a unique 7-bit address allowing for multiple devices to be placed on the same bus. I2C uses two wires, a clock line (SCL) and a data line (SDA). Both lines are open-drain and require pull-up resistors, meaning devices are only able to pull the line low and not drive it high, preventing possible damage. Below is a diagram of a sample I2C bus setup.","title":"I2C"},{"location":"info/communication-protocols/#how-communication-works","text":"Each transaction between the leader and a follower begins with a start condition and ends with a stop condition. Start Condition: occurs when the leader pulls SDA low while SCL is held high. Stop Condition: occurs when the leader releases SDA high while SCL is held high. After a start condition the leader sends a message over the bus consisting of: 7-bit address of follower Read/Write bit (0 = write, 1 = read) ACK bit (the addressed follower pulls SDA low to acknowledge its address was received) Then the actual data transfer begins, sending byte-by-byte with each byte followed by an ACK/NACK bit. After all data is sent the leader sends the stop condition and the bus waits for another transaction.","title":"How Communication Works"},{"location":"info/communication-protocols/#can","text":"Controller Area Network (CAN) is a communication protocol that is used in many embedded systems, especially in industrial and automotive contexts where reliability is important. Devices speak to each other on a CAN bus, which is composed of two wires: CAN High (CANH) and CAN Low (CANL). CAN is a serial, multimaster, multicast protocol, which means that when the bus is free, any node can send a message (multimaster), and all nodes may receive and act on the message (multicast). The CAN protocol has evolved over time. It has three versions, introduced in chronological order: CAN 2.0A CAN 2.0B CAN FD Each version adds more features to the protocol while maintaining backwards compatibility. There are four types of CAN messages, or \u201cframes:\u201d the Data Frame, Remote Frame, Error Frame and Overload Frame. The data frame is the standard CAN message, broadcasting data from the transmitter to the other nodes on the bus. A remote frame is broadcast by a transmitter to request data from a specific node. An error frame may be transmitted by any node that detects a bus error. Overload frames are used to introduce additional delay between data or remote frames. The data frame is the most common frame type and is what this guide will cover. The data frame is made up of two important parts: the identifier and the data. The identifier can be used to determine the priority of the message. The lower the identifier, the higher the priority of the message. Furthermore, the identifier can be used to determine the source of the message, the destination of the message, or the type of message being sent. The data is the actual information being sent by the transmitter to the other nodes on the bus. The length of the identifier and data can vary depending on the version of CAN being used. There are many other fields in the data frame, but for the purposes of this guide, we will only cover the identifier and data. Refer to this document for a more in-depth look at the CAN protocol.","title":"CAN"},{"location":"info/communication-protocols/#can-20","text":"CAN 2.0A is the original version of the CAN protocol. It supports an identifier up to 11 bits and data packets up to 8 bytes in length. CAN 2.0B is an extension of CAN 2.0A. It supports an identifier of either 11 bits or 29 bits and data packets up to 8 bytes in length. The 29-bit identifier allows for more unique identifiers to be used on the bus. All CAN 2.0 messages can be sent at a maximum rate of 1 Mbps.","title":"CAN 2.0"},{"location":"info/communication-protocols/#can-fd","text":"CAN FD is the latest version of the CAN protocol. It supports an identifier of either 11 bits or 29 bits and data packets up to 64 bytes in length. The FD stands for Flexible Data-rate, which means that the data can be sent at a different rate than the rest of the message. This allows for a maximum data rate of 8 Mbps (although 5 Mbps is a more practical limit). The other parts of the message are sent at a maximum rate of 1 Mbps. The rate in which data is sent is often called the \"data rate,\" while the rate in which the rest of the message is sent is called the \"nominal rate.\" As a side note, although CAN FD can send up to 64 bytes of data in a single message, this does not mean that the data payload of the message can be any value up to 64 bytes. The data payload can be the following lengths: 0 to 8, 12, 16, 20, 24, 32, 48, or 64.","title":"CAN FD"},{"location":"info/communication-protocols/#can-bit-timing","text":"When using CAN, you will need to configure the bit timing. The bit timing determines how fast we send and receive messages on the CAN bus. The bit timing parameters are: Prescaler Sync Jump Width Time Seg 1 Time Seg 2 For CAN FD, data can be sent at a different rate than the rest of the message. So we end up with two different sets of bit timing parameters: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Data Prescaler Data Sync Jump Width Data Time Seg 1 Data Time Seg 2 For an in-depth guide on what these values mean, this video , although long, is very informative.","title":"CAN Bit Timing"},{"location":"info/communication-protocols/#can-bus","text":"As mentioned previously, the CAN bus is made up of two wires: CAN High (CANH) and CAN Low (CANL). Microcontrollers, however, do not have the capability to directly interface with the CAN bus. They require a CAN transceiver to convert the digital signals from the microcontroller to the analog signals on the CAN bus. The CAN transceiver also provides protection to the microcontroller from the high voltage on the CAN bus. This is why you will often see CAN TX and RX pins on a microcontroller, but no CANH or CANL pins. The TX and RX pins are connected to the CAN transceiver, which then connects to the CAN bus. Additionally, the CANH and CANL wires are connected to each other at the beginning and end of the bus. This is called termination. The termination is usually done with a 120\u03a9 resistor at each end of the bus. Termination is important because it helps to reduce reflections on the bus, which can cause data errors.","title":"CAN Bus"},{"location":"info/communication-protocols/#using-the-kvaser-bit-timing-calculator","text":"We will go over finding these values for STM32 MCUs using an online tool provided by Kvaser. However, the process is similar for other microcontrollers and CAN hardware. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 For these values, we can use an online tool provided by Kvaser. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay We will go over finding these values for STM32 MCUs . The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 0.005 * 1,000,000 = 5,000 ppm The node delay is the max input/output propagation delay of our CAN transceiver. This value is dependent on the CAN transceiver that we are using. For the TCAN1042, the max propagation delay is 175 ns as shown below. Refer to the datasheet of the transceiver you are using to find this value. With these values, we can now use the Kvaser tool to calculate the bit timing values for our CAN bus. Scroll down to 1. Device Characteristics and make sure to delete the default device that has been added. Then, input the clock frequency, clock tolerance, and node delay. Click Add CAN Device . Then, scroll down to 2. Bitrates and input the desired bitrate for the CAN bus. Click Recalculate . Now in sections 3.1 and 3.2 , you can make changes to the nominal and data sample point percentages. Any percentage from 50% to 90% is acceptable. Many automotive applications use a value around 87.5% for nominal and around 70% - 80% for data. Finally, scroll down to 4. Individual Bus Timing Parameters and you will see the values for the bit timing parameters. You may also modify the prescaler (the data prescaler must be equal to 1 or 2).","title":"Using the Kvaser Bit Timing Calculator"},{"location":"projects/overview26/","text":"ESW 2025-2026 Projects Information about the projects for the ESW 2025-2026 academic year can be found in this Google Doc .","title":"ESW 2025-2026 Projects"},{"location":"projects/overview26/#esw-2025-2026-projects","text":"Information about the projects for the ESW 2025-2026 academic year can be found in this Google Doc .","title":"ESW 2025-2026 Projects"}]}