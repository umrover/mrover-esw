{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MRover Embedded Software The embedded software team (ESW) of MRover writes the driver code that allows the other programming subteams to utilize the electronic equipment on the rover. ESW works primarily with libraries in C, C++, and Python to abstract the functions needed by the other teams for easy use. To do this we use different communication protocols such as CAN and I2C to transmit and receive data from sensors, motors, and various other components. New to ESW? Check out the getting started page for developer setup and starter projects. Overview ESW is split into two groups: Controls and Telemetry. The main difference is simply the subject matter of their projects. Controls handles the control systems on the rover, dealing mainly with brushless and brushed DC motors. We currently use moteus-r4.11 and moteus-n1 brushless controllers from mjbots, however we aim to replace these entirely with our own custom brushless controller. Our brushed controllers are already fully custom and developed by us. Telemetry handles the data and sensing systems on the rover, dealing mainly with the science system.","title":"Home"},{"location":"#mrover-embedded-software","text":"The embedded software team (ESW) of MRover writes the driver code that allows the other programming subteams to utilize the electronic equipment on the rover. ESW works primarily with libraries in C, C++, and Python to abstract the functions needed by the other teams for easy use. To do this we use different communication protocols such as CAN and I2C to transmit and receive data from sensors, motors, and various other components. New to ESW? Check out the getting started page for developer setup and starter projects.","title":"MRover Embedded Software"},{"location":"#overview","text":"ESW is split into two groups: Controls and Telemetry. The main difference is simply the subject matter of their projects. Controls handles the control systems on the rover, dealing mainly with brushless and brushed DC motors. We currently use moteus-r4.11 and moteus-n1 brushless controllers from mjbots, however we aim to replace these entirely with our own custom brushless controller. Our brushed controllers are already fully custom and developed by us. Telemetry handles the data and sensing systems on the rover, dealing mainly with the science system.","title":"Overview"},{"location":"getting-started/intro/","text":"Introduction Welcome to MRover Embedded Software! The Getting Started section is designed to get you up and running as smooth as possible. It consists of three starter projects to help you get experience with using microcontrollers and communication protocols, as well as gain familiarity with the tools we use. There is also useful information linked below to supplement the starter projects. Starter Projects All new members are asked to complete the following: Install STM32Cube* Tools Starter Project: LED Starter Project: Servo Part 1 Starter Project: Servo Part 2 Starter Project: Temperature and Humidity Sensor As everyone comes from varying levels of experience, extra information is provided in these docs to assist the learning process. Please do not hesitate to ask for help! Some helpful references include: Intro to Nucleos Communication Protocols","title":"Introduction"},{"location":"getting-started/intro/#introduction","text":"Welcome to MRover Embedded Software! The Getting Started section is designed to get you up and running as smooth as possible. It consists of three starter projects to help you get experience with using microcontrollers and communication protocols, as well as gain familiarity with the tools we use. There is also useful information linked below to supplement the starter projects.","title":"Introduction"},{"location":"getting-started/intro/#starter-projects","text":"All new members are asked to complete the following: Install STM32Cube* Tools Starter Project: LED Starter Project: Servo Part 1 Starter Project: Servo Part 2 Starter Project: Temperature and Humidity Sensor As everyone comes from varying levels of experience, extra information is provided in these docs to assist the learning process. Please do not hesitate to ask for help! Some helpful references include: Intro to Nucleos Communication Protocols","title":"Starter Projects"},{"location":"getting-started/starter/led/","text":"LED Starter Project About This tutorial is intended to get you more familiar with a Nucleo (with STM32G431RB MCU) and the Cube Tool Suite. You will be asked to develop code such that the LED on the Nucleo will light up whenever the Nucleo\u2019s button is pressed down. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck! Instructions As mentioned earlier, the goal is to make sure that the button is able to activate the LED. As you walk through the guide, keep the following questions in mind: Which pin is linked to the button and which pin is linked to the LED? Are those pins activated on the .ioc file? Have you looked through the HAL drivers to see how to read from and write to pins? Do you know which pins have to be read from and which pins need to be written to? Do you know what to write to the pin that needs to be written to and when? Prerequisites STM32CubeMX installed STM32G431RB Nucleo (pictured below) Guide Open up CubeMX and create a new project called tutorial by following the steps in the CubeMX New Project Guide . When creating a new project, the pins are not configured by default. This matters because on the Nucleo, the button and the LED are already connected to a particular pin so we need to change the pin's functionality if we want to use it. In order to determine which pins are connected to the button and the LED, one can visit this page. On this page, you will find some pinouts. Based on the pinouts, you should be able to tell that the button is connected to pin PC13 and that the LED is connected to PA5. Head back to the CubeMX and open the .ioc file if it is not open already. You should be able to see a graphical interface with the chip on it. The first thing we want to do is set PC13 pin (which is connected to the push button) to be a GPIO input. This means that the pin will be set so that we can choose to read digital input in our code. Reading digital input means that we can read 3.3V as high (logic 1) and read 0V as low (logic 0). This is relevant because this means that we can be able to tell if the push button is pressed down or released. On the graphical interface (also called the .ioc file), locate PC13 and click on it. Then select GPIO_Input to change its configuration. The next thing we want to do is set PA5 (which is connected to the LED) to be a GPIO output. This means that we will be able to make the pin either be set to 3.3V (high) or 0V (low). By default, the pin starts off as low. On the .ioc file, locate PA5 and click on it. Select GPIO_Output to change its configuration. You may need to scroll down a bit. Note that the pin may already be set to GPIO_Output by default, so you may choose to not do anything new. Optionally, right click on PC13 and select \"Enter User Label\" can give it a useful name, such as BUTTON . Do the same for PA5, but call it LED . Make sure to save your changes by saving the file. Either run the keyboard shortcut Ctrl + S on your keyboard or click on File -> Save. Now that you are finished modifying the .ioc file, select \"GENERATE CODE\" in the top right. Once generated successfully, close the confirmation window. We have now successfully configured our pins and generated the code for it. Now it is time to write the logic to link the button and the LED together. Begin by opening up the Src/main.c file in an editor of your choice. When writing code, you will only want to write in specific sections. A good rule of thumb is to only put your code in between where it says USER CODE BEGIN and USER CODE END . This is necessary because otherwise, the automatic code generation from the CubeMX will overwrite and delete your code. We will be using the HAL library so that we can call a single function to perform operations such as reading digital input and writing digital output. The HAL functions that we are interested in are HAL_GPIO_ReadPin(gpio-port, gpio-pin) and HAL_GPIO_WritePin(gpio-port, gpio-pin, pin-state) . See below for a demo on how we can access data in our case. When reading in the pin state PC13, do note that the value read depends on if the button is pushed down or released AND if the button is active low or active high. In our case, the button is active high. This means that when the button is pushed down, the value returned is a 1. Based on this information, you should now be able to implement logic on how to link the button to the LED. If you need additional resources, you may choose to refer to this guide on how to GPIO pins and buttons. Also, you are always welcome to ask another member for help! After writing your code, you will most certainly want to build and run your program on actual hardware. Connect an STM32G431RB Nucleo board to your computer via USB. Ask an experienced member or an ESW lead if you need assistance in obtaining such hardware. Before building your program, ensure that all relevant files have been saved to ensure that code generation has been done. Then, build your project by running the build script from the root of the repository on your command line. The command might look something as follows. ./scripts/build.sh --src <path/to/led/project> After building your project, you should also look over the warnings if you have any since those hint at potential problems in your code. Once your project has built successfully, you will now want to flash the code onto your Nucleo and let it run. Ensure the Nucleo is plugged into your machine, and run the build script again with the --flash option. This will use STM32CubeProgrammer (bundled with STM32CubeCLT) to flash the compiled binary onto the Nucleo. The command will look as follows. ./scripts/build.sh --src <path/to/led/project> --flash Now press down on the button and see if the LED properly lights up. If they do, congratulations! You have completed your first ESW project! Be sure to show a demo of your project to an ESW lead. If you need help debugging, feel free to ask any of the subteam leads or any of the other members. Useful Resources You may or may not need all of these links in the future. Board Reference Manual Chip Datasheet HAL-Driver Pinout","title":"LED"},{"location":"getting-started/starter/led/#led-starter-project","text":"","title":"LED Starter Project"},{"location":"getting-started/starter/led/#about","text":"This tutorial is intended to get you more familiar with a Nucleo (with STM32G431RB MCU) and the Cube Tool Suite. You will be asked to develop code such that the LED on the Nucleo will light up whenever the Nucleo\u2019s button is pressed down. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck!","title":"About"},{"location":"getting-started/starter/led/#instructions","text":"As mentioned earlier, the goal is to make sure that the button is able to activate the LED. As you walk through the guide, keep the following questions in mind: Which pin is linked to the button and which pin is linked to the LED? Are those pins activated on the .ioc file? Have you looked through the HAL drivers to see how to read from and write to pins? Do you know which pins have to be read from and which pins need to be written to? Do you know what to write to the pin that needs to be written to and when?","title":"Instructions"},{"location":"getting-started/starter/led/#prerequisites","text":"STM32CubeMX installed STM32G431RB Nucleo (pictured below)","title":"Prerequisites"},{"location":"getting-started/starter/led/#guide","text":"Open up CubeMX and create a new project called tutorial by following the steps in the CubeMX New Project Guide . When creating a new project, the pins are not configured by default. This matters because on the Nucleo, the button and the LED are already connected to a particular pin so we need to change the pin's functionality if we want to use it. In order to determine which pins are connected to the button and the LED, one can visit this page. On this page, you will find some pinouts. Based on the pinouts, you should be able to tell that the button is connected to pin PC13 and that the LED is connected to PA5. Head back to the CubeMX and open the .ioc file if it is not open already. You should be able to see a graphical interface with the chip on it. The first thing we want to do is set PC13 pin (which is connected to the push button) to be a GPIO input. This means that the pin will be set so that we can choose to read digital input in our code. Reading digital input means that we can read 3.3V as high (logic 1) and read 0V as low (logic 0). This is relevant because this means that we can be able to tell if the push button is pressed down or released. On the graphical interface (also called the .ioc file), locate PC13 and click on it. Then select GPIO_Input to change its configuration. The next thing we want to do is set PA5 (which is connected to the LED) to be a GPIO output. This means that we will be able to make the pin either be set to 3.3V (high) or 0V (low). By default, the pin starts off as low. On the .ioc file, locate PA5 and click on it. Select GPIO_Output to change its configuration. You may need to scroll down a bit. Note that the pin may already be set to GPIO_Output by default, so you may choose to not do anything new. Optionally, right click on PC13 and select \"Enter User Label\" can give it a useful name, such as BUTTON . Do the same for PA5, but call it LED . Make sure to save your changes by saving the file. Either run the keyboard shortcut Ctrl + S on your keyboard or click on File -> Save. Now that you are finished modifying the .ioc file, select \"GENERATE CODE\" in the top right. Once generated successfully, close the confirmation window. We have now successfully configured our pins and generated the code for it. Now it is time to write the logic to link the button and the LED together. Begin by opening up the Src/main.c file in an editor of your choice. When writing code, you will only want to write in specific sections. A good rule of thumb is to only put your code in between where it says USER CODE BEGIN and USER CODE END . This is necessary because otherwise, the automatic code generation from the CubeMX will overwrite and delete your code. We will be using the HAL library so that we can call a single function to perform operations such as reading digital input and writing digital output. The HAL functions that we are interested in are HAL_GPIO_ReadPin(gpio-port, gpio-pin) and HAL_GPIO_WritePin(gpio-port, gpio-pin, pin-state) . See below for a demo on how we can access data in our case. When reading in the pin state PC13, do note that the value read depends on if the button is pushed down or released AND if the button is active low or active high. In our case, the button is active high. This means that when the button is pushed down, the value returned is a 1. Based on this information, you should now be able to implement logic on how to link the button to the LED. If you need additional resources, you may choose to refer to this guide on how to GPIO pins and buttons. Also, you are always welcome to ask another member for help! After writing your code, you will most certainly want to build and run your program on actual hardware. Connect an STM32G431RB Nucleo board to your computer via USB. Ask an experienced member or an ESW lead if you need assistance in obtaining such hardware. Before building your program, ensure that all relevant files have been saved to ensure that code generation has been done. Then, build your project by running the build script from the root of the repository on your command line. The command might look something as follows. ./scripts/build.sh --src <path/to/led/project> After building your project, you should also look over the warnings if you have any since those hint at potential problems in your code. Once your project has built successfully, you will now want to flash the code onto your Nucleo and let it run. Ensure the Nucleo is plugged into your machine, and run the build script again with the --flash option. This will use STM32CubeProgrammer (bundled with STM32CubeCLT) to flash the compiled binary onto the Nucleo. The command will look as follows. ./scripts/build.sh --src <path/to/led/project> --flash Now press down on the button and see if the LED properly lights up. If they do, congratulations! You have completed your first ESW project! Be sure to show a demo of your project to an ESW lead. If you need help debugging, feel free to ask any of the subteam leads or any of the other members.","title":"Guide"},{"location":"getting-started/starter/led/#useful-resources","text":"You may or may not need all of these links in the future. Board Reference Manual Chip Datasheet HAL-Driver Pinout","title":"Useful Resources"},{"location":"getting-started/starter/servo/part1-pwm/","text":"Servo Starter Project - Part 1 - PWM This starter project is made up of two parts: PWM and CAN. This is Part 1 - PWM. By the end of this part, you should have an understanding of timers and PWM (pulse width modulation) signals. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck! Prerequisites STM32Cube installed LED Project completed and shown to an ESW lead Git setup STM32G431RB Nucleo SG90 Servo Intro As mentioned earlier, by the end of the project you should be able to drive a servo. This project will also teach some coding practices used for STM32 code. Similar to our real code, this starter project will be in C++. While you are working through the project, keep the following in mind: How could you document your code so that others can easily read and understand it? How could you write your code so that it can easily be adjusted for different pins, different number of servos, etc.? Guide 1. Setting up the project Since you already have practice creating a project, you will only need to clone and open the premade STM32 project for this starter project. Go to this repository , click the \"Code\" tab, and copy the SSH URL. You now have the URL you need to clone the project. Clone the project onto your local computer by running the following command in your terminal: git clone link-copied-in-above-step Enter the directory: cd mrover-esw Then, create a new branch for yourself git switch -c starter/your-first-name Open STM32CubeMX and open the Servo Part 1 starter project (the directory named p1-pwm ). 2. PWM timer configuration Once the .ioc is open, configure the pins for PWM. Select the PC0 pin on the chip in the .ioc and change it to TIM1_CH1. On the left side of the .ioc file, under Timers, select TIM1 (shown below). Change Channel1 from \"Disable\" to \"PWM Generation CH1\" (shown below). We will now have to configure two values\u2014Prescaler and Counter Period\u2014in order to correctly set up this PWM timer. These values are located in the \"Parameter Settings\" and must be calculated. Refer to the timer reference guide for information on calculating these values. Read the datasheet for the servo and determine what PSC and ARR should be given that the clock frequency of the Nucleo is 72MHz. Once you have determined and edited the timer config, save the file and generate code. Note: you can always come back to the .ioc to make changes. 3. Opening the header file Having a servo object will make it easier to adjust the number servos or where the servos are in the future, so for good practice, we will create a Servo class and declare any member variables and member functions in a header file. On the menu to the left, in Inc , open the header file named servo.hpp . Here, we can see the interface for the Servo class that we will be implementing. The Servo class has 2 member variables: TIM_HandleTypeDef *timer : this tells the STM which timer is being used to generate the PWM signal uint32_t channel : this tells the STM which channel is being used for the PWM signal It also has 3 member functions: A constructor that takes in the timer and channel for the PWM signal A function start_servo() that starts the PWM generation A function set_servo_angle(int angle) that moves the servo to the specified angle 4. Implementing Servo functions Now that we know the interface for the Servo class, it's time to implement the functions. On the menu to the left, in Src , open the C++ source file named servo.cpp . To start the servo, you must initialize the timer used to generate the PWM signal. To do this, use HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel) . Find more information about this built-in HAL function here . When implementing set_servo_angle, keep in mind what PWM signal corresponds to what angle. Check back on the servo datasheet to determine this. In order to set the CCR register to change the PWM signal, you can use __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) . Below is information on this function: /** * @brief Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function. * @param __HANDLE__ TIM handle. * @param __CHANNEL__ TIM Channels to be configured. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @arg TIM_CHANNEL_5: TIM Channel 5 selected * @arg TIM_CHANNEL_6: TIM Channel 6 selected * @param __COMPARE__ specifies the Capture Compare register new value. * @retval None */ #define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) 5. Testing your servo functions Now that we have implemented our Servo class, it's time to test it out. Since this is a C++ project, we will not be using the main.c . Instead, navigate to Src and open driver.cpp . In the new_main() function, create a new Servo using the constructor. The timer parameter for should be a TIM_HandleTypeDef* . The name for the Timer Handle that is being used is at the top of driver.cpp . The channel parameter should correspond with which timer channel you are using (remember we set our pin to TIM1_CH1). Now, we can start the servo using the start_servo() function we created. Then, in the for ( ;; ) loop, change the angle of the servo a few times to make sure your set_servo_angle() function works and that the PSC and ARR you selected in the .ioc are correct. Between each function call make sure to add a delay (Hint: there is a built in HAL function for delays). When you are satisfied with your code, make sure it builds and then get a Nucleo, a logic analyzer, and some jumper cables to check your PWM signals. If you think the PWM signals are correct based on the datasheet , you can test your code on a servo. If you are unsure, just ask for help! Logic Analyzer The simplest method for debugging a digital signal is often to use a logic analyzer. Please install Logic on your laptop. To use Logic, connect PC0 to one of the pins of the logic analyzer and make sure the logic analyzer is grounded to the Nucleo. Then, flash the code and press the play button. If you wrote code in the main while loop to change the servo angle a few times (which you should), you'll notice the signal in Logic changing. Play around with Logic: Zoom in and out Pause the display Mouse over the different parts of the signal Try to understand what all the different numbers mean Wiring the Servo In order to properly wire the servo, first consult the datasheet . How much voltage does the servo need? Which wires are signal, power, and ground? Using a Breadboard A breadboard is broken into two sets of long rails on the outside edges of the board and multiple shorter rails on the inner part of the board. These rails allow for easy connections between wires on the same rail. Below is a picture depicting these rails. In order for the signal to work, the servo and the Nucleo must have a common ground. Connect the servo's ground wire to one of the ground pins on the Nucleo, the power to the appropriate power pin on the Nucleo, and the signal wire to PC0. If you have any questions, don't be afraid to reach out to an ESW lead or SAM(s).","title":"Part 1 - PWM"},{"location":"getting-started/starter/servo/part1-pwm/#servo-starter-project-part-1-pwm","text":"This starter project is made up of two parts: PWM and CAN. This is Part 1 - PWM. By the end of this part, you should have an understanding of timers and PWM (pulse width modulation) signals. Just as a reminder, if you have any questions, feel free to reach out to any of the ESW leads or members. This project isn't meant to be high-stakes, so please reach out if you ever get stuck!","title":"Servo Starter Project - Part 1 - PWM"},{"location":"getting-started/starter/servo/part1-pwm/#prerequisites","text":"STM32Cube installed LED Project completed and shown to an ESW lead Git setup STM32G431RB Nucleo SG90 Servo","title":"Prerequisites"},{"location":"getting-started/starter/servo/part1-pwm/#intro","text":"As mentioned earlier, by the end of the project you should be able to drive a servo. This project will also teach some coding practices used for STM32 code. Similar to our real code, this starter project will be in C++. While you are working through the project, keep the following in mind: How could you document your code so that others can easily read and understand it? How could you write your code so that it can easily be adjusted for different pins, different number of servos, etc.?","title":"Intro"},{"location":"getting-started/starter/servo/part1-pwm/#guide","text":"","title":"Guide"},{"location":"getting-started/starter/servo/part1-pwm/#1-setting-up-the-project","text":"Since you already have practice creating a project, you will only need to clone and open the premade STM32 project for this starter project. Go to this repository , click the \"Code\" tab, and copy the SSH URL. You now have the URL you need to clone the project. Clone the project onto your local computer by running the following command in your terminal: git clone link-copied-in-above-step Enter the directory: cd mrover-esw Then, create a new branch for yourself git switch -c starter/your-first-name Open STM32CubeMX and open the Servo Part 1 starter project (the directory named p1-pwm ).","title":"1. Setting up the project"},{"location":"getting-started/starter/servo/part1-pwm/#2-pwm-timer-configuration","text":"Once the .ioc is open, configure the pins for PWM. Select the PC0 pin on the chip in the .ioc and change it to TIM1_CH1. On the left side of the .ioc file, under Timers, select TIM1 (shown below). Change Channel1 from \"Disable\" to \"PWM Generation CH1\" (shown below). We will now have to configure two values\u2014Prescaler and Counter Period\u2014in order to correctly set up this PWM timer. These values are located in the \"Parameter Settings\" and must be calculated. Refer to the timer reference guide for information on calculating these values. Read the datasheet for the servo and determine what PSC and ARR should be given that the clock frequency of the Nucleo is 72MHz. Once you have determined and edited the timer config, save the file and generate code. Note: you can always come back to the .ioc to make changes.","title":"2. PWM timer configuration"},{"location":"getting-started/starter/servo/part1-pwm/#3-opening-the-header-file","text":"Having a servo object will make it easier to adjust the number servos or where the servos are in the future, so for good practice, we will create a Servo class and declare any member variables and member functions in a header file. On the menu to the left, in Inc , open the header file named servo.hpp . Here, we can see the interface for the Servo class that we will be implementing. The Servo class has 2 member variables: TIM_HandleTypeDef *timer : this tells the STM which timer is being used to generate the PWM signal uint32_t channel : this tells the STM which channel is being used for the PWM signal It also has 3 member functions: A constructor that takes in the timer and channel for the PWM signal A function start_servo() that starts the PWM generation A function set_servo_angle(int angle) that moves the servo to the specified angle","title":"3. Opening the header file"},{"location":"getting-started/starter/servo/part1-pwm/#4-implementing-servo-functions","text":"Now that we know the interface for the Servo class, it's time to implement the functions. On the menu to the left, in Src , open the C++ source file named servo.cpp . To start the servo, you must initialize the timer used to generate the PWM signal. To do this, use HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel) . Find more information about this built-in HAL function here . When implementing set_servo_angle, keep in mind what PWM signal corresponds to what angle. Check back on the servo datasheet to determine this. In order to set the CCR register to change the PWM signal, you can use __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) . Below is information on this function: /** * @brief Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function. * @param __HANDLE__ TIM handle. * @param __CHANNEL__ TIM Channels to be configured. * This parameter can be one of the following values: * @arg TIM_CHANNEL_1: TIM Channel 1 selected * @arg TIM_CHANNEL_2: TIM Channel 2 selected * @arg TIM_CHANNEL_3: TIM Channel 3 selected * @arg TIM_CHANNEL_4: TIM Channel 4 selected * @arg TIM_CHANNEL_5: TIM Channel 5 selected * @arg TIM_CHANNEL_6: TIM Channel 6 selected * @param __COMPARE__ specifies the Capture Compare register new value. * @retval None */ #define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__)","title":"4. Implementing Servo functions"},{"location":"getting-started/starter/servo/part1-pwm/#5-testing-your-servo-functions","text":"Now that we have implemented our Servo class, it's time to test it out. Since this is a C++ project, we will not be using the main.c . Instead, navigate to Src and open driver.cpp . In the new_main() function, create a new Servo using the constructor. The timer parameter for should be a TIM_HandleTypeDef* . The name for the Timer Handle that is being used is at the top of driver.cpp . The channel parameter should correspond with which timer channel you are using (remember we set our pin to TIM1_CH1). Now, we can start the servo using the start_servo() function we created. Then, in the for ( ;; ) loop, change the angle of the servo a few times to make sure your set_servo_angle() function works and that the PSC and ARR you selected in the .ioc are correct. Between each function call make sure to add a delay (Hint: there is a built in HAL function for delays). When you are satisfied with your code, make sure it builds and then get a Nucleo, a logic analyzer, and some jumper cables to check your PWM signals. If you think the PWM signals are correct based on the datasheet , you can test your code on a servo. If you are unsure, just ask for help!","title":"5. Testing your servo functions"},{"location":"getting-started/starter/servo/part1-pwm/#logic-analyzer","text":"The simplest method for debugging a digital signal is often to use a logic analyzer. Please install Logic on your laptop. To use Logic, connect PC0 to one of the pins of the logic analyzer and make sure the logic analyzer is grounded to the Nucleo. Then, flash the code and press the play button. If you wrote code in the main while loop to change the servo angle a few times (which you should), you'll notice the signal in Logic changing. Play around with Logic: Zoom in and out Pause the display Mouse over the different parts of the signal Try to understand what all the different numbers mean","title":"Logic Analyzer"},{"location":"getting-started/starter/servo/part1-pwm/#wiring-the-servo","text":"In order to properly wire the servo, first consult the datasheet . How much voltage does the servo need? Which wires are signal, power, and ground?","title":"Wiring the Servo"},{"location":"getting-started/starter/servo/part1-pwm/#using-a-breadboard","text":"A breadboard is broken into two sets of long rails on the outside edges of the board and multiple shorter rails on the inner part of the board. These rails allow for easy connections between wires on the same rail. Below is a picture depicting these rails. In order for the signal to work, the servo and the Nucleo must have a common ground. Connect the servo's ground wire to one of the ground pins on the Nucleo, the power to the appropriate power pin on the Nucleo, and the signal wire to PC0. If you have any questions, don't be afraid to reach out to an ESW lead or SAM(s).","title":"Using a Breadboard"},{"location":"getting-started/starter/servo/part2-can/","text":"Servo Starter Project - Part 2 - CAN This starter project is made up of two parts: PWM and CAN. This is Part 2 - CAN. In this project, you will be using the CAN peripheral on the STM32G431RB Nucleo to send a CAN message to another Nucleo board. The message will contain information about the angle the servo should be set to. If you send a successful message, the servo on the other board should rotate to the specified angle. By the end of this part, you should have an understanding of the CAN (Controller Area Network) communication protocol. Just as a reminder, if you have any questions, feel free to reach out to any ESW lead or member. Before starting this project , please give the CAN info page a read. It will get you start on the basics of CAN communication. Do not read \"Using the Kvaser Bit Timing Calculator.\" Prerequisites STM32Cube installed LED Starter Project completed and shown to an ESW lead Servo Part 1 Starter Project completed and shown to an ESW lead STM32G431RB Nucleo MCP2551 CAN tranceiver Guide 1. Setting up the project Assuming you have already completed the Servo Part 1 Starter Project, you will not have to clone the project again. Open STM32CubeIDE and open the Servo Part 2 starter project (the directory named p2-can ). 2. Understanding our CAN bus In order to send messages to the CAN bus, we need to understand how our CAN bus is set up. The servo board that we are sending messages to is set up to receive CAN 2.0B messages with an extended identifier at a baud rate of 500 kbps . It will only respond to messages with the identifier 2024 . It will then read only the first byte of the data payload and set the servo to the angle specified in that byte. The angle must be between 0 and 180 degrees. For example, if we send a message with the identifier 2024 and the data payload 90 (decimal), the servo will rotate to 90 degrees. 3. CAN configuration Once the .ioc is open, activate the FDCAN peripheral. We can do this by clicking on the FDCAN peripheral in the Connectivity tab on the left side of the .ioc. Then, check the Activated box. Next, we need to configure the timings for the CAN bus. Click on the Parameter Settings tab (as shown above). We will be using CAN 2.0B not CAN FD, so Frame Format should be set to \"Classic.\" Since we are using \"Classic,\" we do not need to worry about the data bit rate. We will only need to properly set the following values: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Again, please refer to the CAN info page for more information on these values. There is a very in depth guide to configuring these values for STM32 MCUs in the CAN FD Bit Timing section of the docs. However, for the purposes of this starter project, you can use this online calculator designed for STM32G4 boards. Our FDCAN peripheral is clocked at 72 MHz, and the CAN bus we are trying to communicate on is running at 500 kbps. The calculator will give you the values you need to input into the .ioc. Ignore all CAN FD related values in the calculator. For Nominal Sync Jump Width, make sure to read the note at the bottom of the calculator. After inputting the bit timing parameters, ensure that Nominal Baud Rate is 500,000 bit/s. You can now save the .ioc and generate the code. 4. Writing the CAN code In the main.c , you should see 6 TODOs. We will walk through each of them. As a reminder, when you are writing code, make sure to write within the /* USER CODE */ tags. This will ensure that your code is not overwritten when you regenerate the code. TODO 1: Create the necessary variables to send a CAN message In order to send a CAN message, we need to create two objects: The message header The message data The message header is an object of type FDCAN_TxHeaderTypeDef . This will store information about the CAN message we are sending, such as the identifier, the data length, the frame format, etc. The message data is an array of bytes that will be sent in the CAN message. In this project, we will only be sending one byte of data, which will represent the angle the servo should be set to. To declare a byte of data, you can use the uint8_t type. TODO 2: Start the CAN peripheral We'll notice that there towards the top of the main.c file, there is the following object: FDCAN_HandleTypeDef hfdcan1; This is the handle for the FDCAN peripheral. We will need to initialize the FDCAN peripheral using the HAL_FDCAN_Start function. This function takes in the handle for the FDCAN peripheral. We can use the following code snippet to start the FDCAN peripheral: HAL_FDCAN_Start(&hfdcan1); TODO 3: Form the CAN message header In this step, we will need to fill out the FDCAN_TxHeaderTypeDef object that we created in TODO 1 with the necessary information to send a CAN message. Below is the structure of the FDCAN_TxHeaderTypeDef object: /** * @brief FDCAN Tx header structure definition */ typedef struct { uint32_t Identifier; /*!< Specifies the identifier. This parameter must be a number between: - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID */ uint32_t IdType; /*!< Specifies the identifier type for the message that will be transmitted. This parameter can be a value of @ref FDCAN_id_type */ uint32_t TxFrameType; /*!< Specifies the frame type of the message that will be transmitted. This parameter can be a value of @ref FDCAN_frame_type */ uint32_t DataLength; /*!< Specifies the length of the frame that will be transmitted. This parameter can be a value of @ref FDCAN_data_length_code */ uint32_t ErrorStateIndicator; /*!< Specifies the error state indicator. This parameter can be a value of @ref FDCAN_error_state_indicator */ uint32_t BitRateSwitch; /*!< Specifies whether the Tx frame will be transmitted with or without bit rate switching. This parameter can be a value of @ref FDCAN_bit_rate_switching */ uint32_t FDFormat; /*!< Specifies whether the Tx frame will be transmitted in classic or FD format. This parameter can be a value of @ref FDCAN_format */ uint32_t TxEventFifoControl; /*!< Specifies the event FIFO control. This parameter can be a value of @ref FDCAN_EFC */ uint32_t MessageMarker; /*!< Specifies the message marker to be copied into Tx Event FIFO element for identification of Tx message status. This parameter must be a number between 0 and 0xFF */ } FDCAN_TxHeaderTypeDef; The following code snippet shows how to fill out the FDCAN_TxHeaderTypeDef object to send a Classic CAN (CAN 2.0) message with a standard identifier of 88 and a data length of 8 bytes: // In TODO 1: // FDCAN_TxHeaderTypeDef TxHeader; TxHeader.Identifier = 88; TxHeader.IdType = FDCAN_STANDARD_ID; TxHeader.TxFrameType = FDCAN_DATA_FRAME; TxHeader.DataLength = FDCAN_DLC_BYTES_8; TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE; TxHeader.BitRateSwitch = FDCAN_BRS_OFF; TxHeader.FDFormat = FDCAN_CLASSIC_CAN; TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS; TxHeader.MessageMarker = 0; We will need to fill out the FDCAN_TxHeaderTypeDef object with the correct values for the CAN message you are trying to send. Refer back to 2. Understanding our CAN bus for this information. TODO 4-6: Send a CAN message to rotate the servo Now that we have the CAN message header for all the messages we want to send, we can send the message using the HAL_FDCAN_AddMessageToTxFifoQ function. This function takes in the handle for the FDCAN peripheral, the message header, and the message data. Here is an example of how to send a CAN message to turn the servo to 45 degrees: // In TODO 1: // uint8_t TxData[1]; TxData[0] = 45; HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &TxHeader, TxData); 5. Testing the project We will now connect to the CAN bus that the other Nucleo board is connected to. We will be using the MCP2551 CAN transceiver to connect to the CAN bus. For access to the CAN bus, please ask an ESW lead. The CAN TX and RX pins on the STM32G431RB Nucleo can be found in the .ioc file. These pins should connect to the CAN TX and RX pins on the MCP2551 CAN transceiver. The CANH and CANL pins on the MCP2551 should connect to the CANH and CANL pins on the CAN bus. We will now be able to test the project. To do this, we will need to build and flash the code onto the STM32G431RB Nucleo board. Once you have flashed the code, you should see the servo rotate to the angle specified in the CAN messages.","title":"Part 2 - CAN"},{"location":"getting-started/starter/servo/part2-can/#servo-starter-project-part-2-can","text":"This starter project is made up of two parts: PWM and CAN. This is Part 2 - CAN. In this project, you will be using the CAN peripheral on the STM32G431RB Nucleo to send a CAN message to another Nucleo board. The message will contain information about the angle the servo should be set to. If you send a successful message, the servo on the other board should rotate to the specified angle. By the end of this part, you should have an understanding of the CAN (Controller Area Network) communication protocol. Just as a reminder, if you have any questions, feel free to reach out to any ESW lead or member. Before starting this project , please give the CAN info page a read. It will get you start on the basics of CAN communication. Do not read \"Using the Kvaser Bit Timing Calculator.\"","title":"Servo Starter Project - Part 2 - CAN"},{"location":"getting-started/starter/servo/part2-can/#prerequisites","text":"STM32Cube installed LED Starter Project completed and shown to an ESW lead Servo Part 1 Starter Project completed and shown to an ESW lead STM32G431RB Nucleo MCP2551 CAN tranceiver","title":"Prerequisites"},{"location":"getting-started/starter/servo/part2-can/#guide","text":"","title":"Guide"},{"location":"getting-started/starter/servo/part2-can/#1-setting-up-the-project","text":"Assuming you have already completed the Servo Part 1 Starter Project, you will not have to clone the project again. Open STM32CubeIDE and open the Servo Part 2 starter project (the directory named p2-can ).","title":"1. Setting up the project"},{"location":"getting-started/starter/servo/part2-can/#2-understanding-our-can-bus","text":"In order to send messages to the CAN bus, we need to understand how our CAN bus is set up. The servo board that we are sending messages to is set up to receive CAN 2.0B messages with an extended identifier at a baud rate of 500 kbps . It will only respond to messages with the identifier 2024 . It will then read only the first byte of the data payload and set the servo to the angle specified in that byte. The angle must be between 0 and 180 degrees. For example, if we send a message with the identifier 2024 and the data payload 90 (decimal), the servo will rotate to 90 degrees.","title":"2. Understanding our CAN bus"},{"location":"getting-started/starter/servo/part2-can/#3-can-configuration","text":"Once the .ioc is open, activate the FDCAN peripheral. We can do this by clicking on the FDCAN peripheral in the Connectivity tab on the left side of the .ioc. Then, check the Activated box. Next, we need to configure the timings for the CAN bus. Click on the Parameter Settings tab (as shown above). We will be using CAN 2.0B not CAN FD, so Frame Format should be set to \"Classic.\" Since we are using \"Classic,\" we do not need to worry about the data bit rate. We will only need to properly set the following values: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Again, please refer to the CAN info page for more information on these values. There is a very in depth guide to configuring these values for STM32 MCUs in the CAN FD Bit Timing section of the docs. However, for the purposes of this starter project, you can use this online calculator designed for STM32G4 boards. Our FDCAN peripheral is clocked at 72 MHz, and the CAN bus we are trying to communicate on is running at 500 kbps. The calculator will give you the values you need to input into the .ioc. Ignore all CAN FD related values in the calculator. For Nominal Sync Jump Width, make sure to read the note at the bottom of the calculator. After inputting the bit timing parameters, ensure that Nominal Baud Rate is 500,000 bit/s. You can now save the .ioc and generate the code.","title":"3. CAN configuration"},{"location":"getting-started/starter/servo/part2-can/#4-writing-the-can-code","text":"In the main.c , you should see 6 TODOs. We will walk through each of them. As a reminder, when you are writing code, make sure to write within the /* USER CODE */ tags. This will ensure that your code is not overwritten when you regenerate the code.","title":"4. Writing the CAN code"},{"location":"getting-started/starter/servo/part2-can/#todo-1-create-the-necessary-variables-to-send-a-can-message","text":"In order to send a CAN message, we need to create two objects: The message header The message data The message header is an object of type FDCAN_TxHeaderTypeDef . This will store information about the CAN message we are sending, such as the identifier, the data length, the frame format, etc. The message data is an array of bytes that will be sent in the CAN message. In this project, we will only be sending one byte of data, which will represent the angle the servo should be set to. To declare a byte of data, you can use the uint8_t type.","title":"TODO 1: Create the necessary variables to send a CAN message"},{"location":"getting-started/starter/servo/part2-can/#todo-2-start-the-can-peripheral","text":"We'll notice that there towards the top of the main.c file, there is the following object: FDCAN_HandleTypeDef hfdcan1; This is the handle for the FDCAN peripheral. We will need to initialize the FDCAN peripheral using the HAL_FDCAN_Start function. This function takes in the handle for the FDCAN peripheral. We can use the following code snippet to start the FDCAN peripheral: HAL_FDCAN_Start(&hfdcan1);","title":"TODO 2: Start the CAN peripheral"},{"location":"getting-started/starter/servo/part2-can/#todo-3-form-the-can-message-header","text":"In this step, we will need to fill out the FDCAN_TxHeaderTypeDef object that we created in TODO 1 with the necessary information to send a CAN message. Below is the structure of the FDCAN_TxHeaderTypeDef object: /** * @brief FDCAN Tx header structure definition */ typedef struct { uint32_t Identifier; /*!< Specifies the identifier. This parameter must be a number between: - 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID - 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID */ uint32_t IdType; /*!< Specifies the identifier type for the message that will be transmitted. This parameter can be a value of @ref FDCAN_id_type */ uint32_t TxFrameType; /*!< Specifies the frame type of the message that will be transmitted. This parameter can be a value of @ref FDCAN_frame_type */ uint32_t DataLength; /*!< Specifies the length of the frame that will be transmitted. This parameter can be a value of @ref FDCAN_data_length_code */ uint32_t ErrorStateIndicator; /*!< Specifies the error state indicator. This parameter can be a value of @ref FDCAN_error_state_indicator */ uint32_t BitRateSwitch; /*!< Specifies whether the Tx frame will be transmitted with or without bit rate switching. This parameter can be a value of @ref FDCAN_bit_rate_switching */ uint32_t FDFormat; /*!< Specifies whether the Tx frame will be transmitted in classic or FD format. This parameter can be a value of @ref FDCAN_format */ uint32_t TxEventFifoControl; /*!< Specifies the event FIFO control. This parameter can be a value of @ref FDCAN_EFC */ uint32_t MessageMarker; /*!< Specifies the message marker to be copied into Tx Event FIFO element for identification of Tx message status. This parameter must be a number between 0 and 0xFF */ } FDCAN_TxHeaderTypeDef; The following code snippet shows how to fill out the FDCAN_TxHeaderTypeDef object to send a Classic CAN (CAN 2.0) message with a standard identifier of 88 and a data length of 8 bytes: // In TODO 1: // FDCAN_TxHeaderTypeDef TxHeader; TxHeader.Identifier = 88; TxHeader.IdType = FDCAN_STANDARD_ID; TxHeader.TxFrameType = FDCAN_DATA_FRAME; TxHeader.DataLength = FDCAN_DLC_BYTES_8; TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE; TxHeader.BitRateSwitch = FDCAN_BRS_OFF; TxHeader.FDFormat = FDCAN_CLASSIC_CAN; TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS; TxHeader.MessageMarker = 0; We will need to fill out the FDCAN_TxHeaderTypeDef object with the correct values for the CAN message you are trying to send. Refer back to 2. Understanding our CAN bus for this information.","title":"TODO 3: Form the CAN message header"},{"location":"getting-started/starter/servo/part2-can/#todo-4-6-send-a-can-message-to-rotate-the-servo","text":"Now that we have the CAN message header for all the messages we want to send, we can send the message using the HAL_FDCAN_AddMessageToTxFifoQ function. This function takes in the handle for the FDCAN peripheral, the message header, and the message data. Here is an example of how to send a CAN message to turn the servo to 45 degrees: // In TODO 1: // uint8_t TxData[1]; TxData[0] = 45; HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &TxHeader, TxData);","title":"TODO 4-6: Send a CAN message to rotate the servo"},{"location":"getting-started/starter/servo/part2-can/#5-testing-the-project","text":"We will now connect to the CAN bus that the other Nucleo board is connected to. We will be using the MCP2551 CAN transceiver to connect to the CAN bus. For access to the CAN bus, please ask an ESW lead. The CAN TX and RX pins on the STM32G431RB Nucleo can be found in the .ioc file. These pins should connect to the CAN TX and RX pins on the MCP2551 CAN transceiver. The CANH and CANL pins on the MCP2551 should connect to the CANH and CANL pins on the CAN bus. We will now be able to test the project. To do this, we will need to build and flash the code onto the STM32G431RB Nucleo board. Once you have flashed the code, you should see the servo rotate to the angle specified in the CAN messages.","title":"5. Testing the project"},{"location":"getting-started/starter/temp-humidity/","text":"Temperature and Humidity Starter Project About The purpose of this starter project is to guide you through reading data from the AHT20 Temperature and Humidity Sensor using I2C with an STM32 Nucleo Hardware Nucleo STM32G431RB AHT20 Temperature and Humidity Sensor Lots of female-to-male, male-to-male, and female-to-female wires! 1 USB A to mini B cable Breadboard Data Sheets and Pinouts AHT20 Sensor datasheet Nucleo STM32G431RB User Manual (pinout on page 29) Hexadecimal Hexadecimal is a numbering system which uses base-16. Unlike our usual base-10 decimal system (0123456789) or the base-2 binary system (01), hexadecimal has a total of 16 different digits (0123456789ABCDEF). We tend to use hexadecimal to express our binary-based ideas because it is easier to read and easy to convert to and from binary. Each hexadecimal digit is equal to four bits (binary digits). For example, Hex number 0xA is equivalent to binary number 0b1010, or decimal number 10. Because of this a byte can be represented by two hexadecimal digits (8 bits). Most numbers in the datasheet will be expressed in hexadecimal, especially when referring to addresses, memory locations, or registers. Here is a good online converter for going from binary to hex. Go ahead and use that calculator to convert the binary string to hex. A thing to note about hex values is that they are commonly prefixed by 0x . What are LSB and MSB? We may have to work with data values which are many bytes long. However, sometimes we are restricted to working with just one byte at a time. Therefore, we split large data values into \"most significant\" and \"least significant\" bytes. The AHT20 returns temperature and humidity values as 2.5 byte raw values. However, each byte is sent individually, so to get the full raw temperature and humidity values we will need to combine the 2.5 bytes using the logical left shift operator (<<). As a decimal analogy to this, imagine you have the number 2048. In MSB/LSB format it could be split up as 20 and 48. In order to combine the two correctly, you have to shift 20 over 2 decimal places (multiply by 10^2) and then add it to 48. When it comes to retrieving and combining the data of the 2.5 bytes, the idea is the same. Splitting the data to be sent into multiple registers allows for higher precision data to be sent. More in depth info . What is I2C? I2C offers two-way communication between a device such as the AHT20 (slave) and the Nucleo (master). Notice the SDA (Serial Data) and SCL (Serial Clock) pins on both the AHT20 sensor and the Nucleo. I2C relies on the clock line (SCL) to keep time between the devices connected so that they can communicate at the same rate. The data line (SDA) is a shared data line between the devices. Each device enabled with I2C also has a 7 bit address. Try to find the address for the AHT20 sensor in the datasheet . Read this if you want to learn more about I2C. What is an I2C address? A master device can have multiple slaves. Therefore, each slave device needs a distinct address which the master can use to select the correct device to communicate with over the I2C bus. The AHT20 I2C address we will need to write to and read from is found here . What are Callbacks? A callback is a function that is called automatically when an operation finishes (like I2C read and write operations). We don't need to make these function calls ourselves, the microcontroller instead does it for us. We will use I2C transmit and recieve callbacks to handle communicating with the AHT20 sensor without having to block other code from finishing while we wait for transmits/recieves to finish. Starter code If you already cloned mrover-esw for the other starter projects , you do not need to do it again for the temperature and humidity sensor. To get the starter code, open up a new terminal window, clone the mrover-esw repository, and make a tutorial branch for yourself\\ $ git clone https://github.com/umrover/mrover-esw (if not already cloned)\\ $ cd mrover-esw \\ $ git checkout -b starter/<name> Open up the Cube IDE project by opening the folder and double clicking on the .project file. Make sure that you already have Cube IDE installed. Wiring and Set up Notice that the AHT20 sensor has 4 pins: VIN (voltage input), GND (ground), SCL (I2C clock line), and SDA (I2C data line). We will use the jumper wires and breadboard from the hardware step to make appropriate connections to all four pins. To wire the sensor connect the VIN pin on the AHT20 sensor to the 3.3V pin on the nucleo and the GND pin on the AHT20 sensor to the GND pin on the nucleo. To use I2C we will need to connect the clock and data pins of the AHT20 sensor to the clock and data pins on the nucleo that we configured in our .ioc file. To see which pins we are using for I2C on the nucleo open the .ioc file and search for the pins set to I2C3_SCL and I2C3_SDA. Finally, make connections to the pins corresponding to I2C3_SCL and I2C3_SDA on the nucleo using the pinout found on page 29 here . Getting Started Notice that the starter file for the project already contains multiple variable definitions. To begin set the value of the TEMP_HUM_ADDRESS constant to the AHT20 address found earlier. We will use this constant throughout our code when interacting with the sensor over I2C. Also notice the init() function which is called once, and has the job of pointing the \"i2c\" pointer to the hi2c3 object and also calling the eventLoop() function, which is the infinite loop that we will use to constantly send and receive data from the AHT20 sensor. The process for receiving data from the AHT20 sensor can be broken into 3 main steps: - Transmit a command (found in the datasheet) to the sensor to start a measurement, using the HAL_I2C_Master_Transmit_IT function. - Implement the HAL_I2C_MasterTxCpltCallback callback function, which will be called when the sensor has finished measuring and storing the new temperature and humidity values. We need these values so you will need to request them using the HAL_I2C_Master_Receive_IT function and by providing the buffer defined earlier in the code. The buffer will be the location in which the received bytes will be stored. - Finally implement the HAL_I2C_MasterRxCpltCallback callback function, which will be called when the sensor has sent us the raw values and the buffer is populated. You will then need to convert the raw values to the actual temperature and humidity values found in the datasheet. Important Notes and Tips Define functions for transmitting, receiving, and converting values to and from the AHT20 sensor outside of the eventLoop and I2C callback functions and then call these functions when necessary. As described in the datasheet the AHT20 requires a delay after powering on the sensor. Find the delay and add it to the start of your code. The address parameters of the HAL I2C receive and transmit functions will need to be provided with 8 bits, bits 1-7 will be the AHT20's ID and bit 0 represents whether you are writing/reading (0/1) to the sensor. You can accomplish this using the logical left shift operator (<<) and the bitwise or operator (|). When converting the raw values from the buffer to the actual sensor values use the datasheet to determine which bytes from the buffer correspond to temperature/humidity and use the logical left shift operator (<<) to combine them into a single value. Then use the conversion formula from the datasheet to find the actual temperature and humidity values. Testing In this tutorial we do not print out data anywhere. Because of this you will have to use the debugger to view the temperature and humidity measurements you get from the sensor. This is good practice for what you may expect to see in the future. Debugging in Cube IDE Make sure that your Nucleo is properly connected to your computer and that you can build your project. Click on Run -> Debug As -> 1 STM32 C/C++ Application. On the following screen, you can just press OK. If your device is unable to detect the Nucleo connected to it, you may see the following screen. Retry the previous steps and if that does not work, then either double check your connections, or seek a new Nucleo board. In the future, you may be able to get away with just clicking on Run -> Debug, or using the keyboard shortcut F11. This does not work the first time if you have never clicked on the Debug As button. Now that you're in the debug mode, you may set breakpoints and run through your code or pause at any given moment. When paused, we can also see the values of certain variables. We will use this feature to view if the data we are reading for our temperature and humidity sensor is reasonable. Congratulations! You have completed the temperature and humidity sensor starter project! Contact one the ESW leads for further instructions.","title":"Temp-Humidity"},{"location":"getting-started/starter/temp-humidity/#temperature-and-humidity-starter-project","text":"","title":"Temperature and Humidity Starter Project"},{"location":"getting-started/starter/temp-humidity/#about","text":"The purpose of this starter project is to guide you through reading data from the AHT20 Temperature and Humidity Sensor using I2C with an STM32 Nucleo","title":"About"},{"location":"getting-started/starter/temp-humidity/#hardware","text":"Nucleo STM32G431RB AHT20 Temperature and Humidity Sensor Lots of female-to-male, male-to-male, and female-to-female wires! 1 USB A to mini B cable Breadboard","title":"Hardware"},{"location":"getting-started/starter/temp-humidity/#data-sheets-and-pinouts","text":"AHT20 Sensor datasheet Nucleo STM32G431RB User Manual (pinout on page 29)","title":"Data Sheets and Pinouts"},{"location":"getting-started/starter/temp-humidity/#hexadecimal","text":"Hexadecimal is a numbering system which uses base-16. Unlike our usual base-10 decimal system (0123456789) or the base-2 binary system (01), hexadecimal has a total of 16 different digits (0123456789ABCDEF). We tend to use hexadecimal to express our binary-based ideas because it is easier to read and easy to convert to and from binary. Each hexadecimal digit is equal to four bits (binary digits). For example, Hex number 0xA is equivalent to binary number 0b1010, or decimal number 10. Because of this a byte can be represented by two hexadecimal digits (8 bits). Most numbers in the datasheet will be expressed in hexadecimal, especially when referring to addresses, memory locations, or registers. Here is a good online converter for going from binary to hex. Go ahead and use that calculator to convert the binary string to hex. A thing to note about hex values is that they are commonly prefixed by 0x .","title":"Hexadecimal"},{"location":"getting-started/starter/temp-humidity/#what-are-lsb-and-msb","text":"We may have to work with data values which are many bytes long. However, sometimes we are restricted to working with just one byte at a time. Therefore, we split large data values into \"most significant\" and \"least significant\" bytes. The AHT20 returns temperature and humidity values as 2.5 byte raw values. However, each byte is sent individually, so to get the full raw temperature and humidity values we will need to combine the 2.5 bytes using the logical left shift operator (<<). As a decimal analogy to this, imagine you have the number 2048. In MSB/LSB format it could be split up as 20 and 48. In order to combine the two correctly, you have to shift 20 over 2 decimal places (multiply by 10^2) and then add it to 48. When it comes to retrieving and combining the data of the 2.5 bytes, the idea is the same. Splitting the data to be sent into multiple registers allows for higher precision data to be sent. More in depth info .","title":"What are LSB and MSB?"},{"location":"getting-started/starter/temp-humidity/#what-is-i2c","text":"I2C offers two-way communication between a device such as the AHT20 (slave) and the Nucleo (master). Notice the SDA (Serial Data) and SCL (Serial Clock) pins on both the AHT20 sensor and the Nucleo. I2C relies on the clock line (SCL) to keep time between the devices connected so that they can communicate at the same rate. The data line (SDA) is a shared data line between the devices. Each device enabled with I2C also has a 7 bit address. Try to find the address for the AHT20 sensor in the datasheet . Read this if you want to learn more about I2C.","title":"What is I2C?"},{"location":"getting-started/starter/temp-humidity/#what-is-an-i2c-address","text":"A master device can have multiple slaves. Therefore, each slave device needs a distinct address which the master can use to select the correct device to communicate with over the I2C bus. The AHT20 I2C address we will need to write to and read from is found here .","title":"What is an I2C address?"},{"location":"getting-started/starter/temp-humidity/#what-are-callbacks","text":"A callback is a function that is called automatically when an operation finishes (like I2C read and write operations). We don't need to make these function calls ourselves, the microcontroller instead does it for us. We will use I2C transmit and recieve callbacks to handle communicating with the AHT20 sensor without having to block other code from finishing while we wait for transmits/recieves to finish.","title":"What are Callbacks?"},{"location":"getting-started/starter/temp-humidity/#starter-code","text":"If you already cloned mrover-esw for the other starter projects , you do not need to do it again for the temperature and humidity sensor. To get the starter code, open up a new terminal window, clone the mrover-esw repository, and make a tutorial branch for yourself\\ $ git clone https://github.com/umrover/mrover-esw (if not already cloned)\\ $ cd mrover-esw \\ $ git checkout -b starter/<name> Open up the Cube IDE project by opening the folder and double clicking on the .project file. Make sure that you already have Cube IDE installed.","title":"Starter code"},{"location":"getting-started/starter/temp-humidity/#wiring-and-set-up","text":"Notice that the AHT20 sensor has 4 pins: VIN (voltage input), GND (ground), SCL (I2C clock line), and SDA (I2C data line). We will use the jumper wires and breadboard from the hardware step to make appropriate connections to all four pins. To wire the sensor connect the VIN pin on the AHT20 sensor to the 3.3V pin on the nucleo and the GND pin on the AHT20 sensor to the GND pin on the nucleo. To use I2C we will need to connect the clock and data pins of the AHT20 sensor to the clock and data pins on the nucleo that we configured in our .ioc file. To see which pins we are using for I2C on the nucleo open the .ioc file and search for the pins set to I2C3_SCL and I2C3_SDA. Finally, make connections to the pins corresponding to I2C3_SCL and I2C3_SDA on the nucleo using the pinout found on page 29 here .","title":"Wiring and Set up"},{"location":"getting-started/starter/temp-humidity/#getting-started","text":"Notice that the starter file for the project already contains multiple variable definitions. To begin set the value of the TEMP_HUM_ADDRESS constant to the AHT20 address found earlier. We will use this constant throughout our code when interacting with the sensor over I2C. Also notice the init() function which is called once, and has the job of pointing the \"i2c\" pointer to the hi2c3 object and also calling the eventLoop() function, which is the infinite loop that we will use to constantly send and receive data from the AHT20 sensor. The process for receiving data from the AHT20 sensor can be broken into 3 main steps: - Transmit a command (found in the datasheet) to the sensor to start a measurement, using the HAL_I2C_Master_Transmit_IT function. - Implement the HAL_I2C_MasterTxCpltCallback callback function, which will be called when the sensor has finished measuring and storing the new temperature and humidity values. We need these values so you will need to request them using the HAL_I2C_Master_Receive_IT function and by providing the buffer defined earlier in the code. The buffer will be the location in which the received bytes will be stored. - Finally implement the HAL_I2C_MasterRxCpltCallback callback function, which will be called when the sensor has sent us the raw values and the buffer is populated. You will then need to convert the raw values to the actual temperature and humidity values found in the datasheet.","title":"Getting Started"},{"location":"getting-started/starter/temp-humidity/#important-notes-and-tips","text":"Define functions for transmitting, receiving, and converting values to and from the AHT20 sensor outside of the eventLoop and I2C callback functions and then call these functions when necessary. As described in the datasheet the AHT20 requires a delay after powering on the sensor. Find the delay and add it to the start of your code. The address parameters of the HAL I2C receive and transmit functions will need to be provided with 8 bits, bits 1-7 will be the AHT20's ID and bit 0 represents whether you are writing/reading (0/1) to the sensor. You can accomplish this using the logical left shift operator (<<) and the bitwise or operator (|). When converting the raw values from the buffer to the actual sensor values use the datasheet to determine which bytes from the buffer correspond to temperature/humidity and use the logical left shift operator (<<) to combine them into a single value. Then use the conversion formula from the datasheet to find the actual temperature and humidity values.","title":"Important Notes and Tips"},{"location":"getting-started/starter/temp-humidity/#testing","text":"In this tutorial we do not print out data anywhere. Because of this you will have to use the debugger to view the temperature and humidity measurements you get from the sensor. This is good practice for what you may expect to see in the future.","title":"Testing"},{"location":"getting-started/starter/temp-humidity/#debugging-in-cube-ide","text":"Make sure that your Nucleo is properly connected to your computer and that you can build your project. Click on Run -> Debug As -> 1 STM32 C/C++ Application. On the following screen, you can just press OK. If your device is unable to detect the Nucleo connected to it, you may see the following screen. Retry the previous steps and if that does not work, then either double check your connections, or seek a new Nucleo board. In the future, you may be able to get away with just clicking on Run -> Debug, or using the keyboard shortcut F11. This does not work the first time if you have never clicked on the Debug As button. Now that you're in the debug mode, you may set breakpoints and run through your code or pause at any given moment. When paused, we can also see the values of certain variables. We will use this feature to view if the data we are reading for our temperature and humidity sensor is reasonable.","title":"Debugging in Cube IDE"},{"location":"getting-started/starter/temp-humidity/#congratulations","text":"You have completed the temperature and humidity sensor starter project! Contact one the ESW leads for further instructions.","title":"Congratulations!"},{"location":"getting-started/stm32cube/","text":"STM32Cube* About STM32CubeMX and STM32CubeCLT allow the user to write, compile, and flash code to the STM32 microcontroller! STM32CubeCLT contains the GCC compiler and GDB debugging tool for firmware compilation and debugging, and STM32CubeMX contains the interface for configuring the microcontroller and project environment, and provides a very powerful interface for automatic code generation, allowing the user to initialize an entire module with a few clicks of a button, and have that code show up automatically in the main file. Note If you've taken EECS 373, you have used STM32CubeIDE, which is an IDE that packages both of these tools together. However, STM32CubeIDE is a very heavy program, so we choose to use the lighter weight STM32CubeMX and STM32CubeCLT tools in combination with CMake and your favorite text editor or IDE. Downloading and Installing CubeMX 1. Download CubeMX Go to the CubeMX download page and scroll down to \"Get Software.\" For this walkthrough, we will be using the Linux installer for UBUNTU USERS. Click on \"Select Version\", then select the newest version for the correct OS you are running!!! Click on Accept for the License Agreement pop up. You will then be prompted to log in, create an account, or continue as a guest. You will need a MyST account in the future, so it is best to create one now. You may use any email address. After logging in and being brought back to the download page, the download should start automatically. Scroll down and select the correct version from \"Get Software\" if it does not. 2. Install CubeMX Note : This install guide is for Linux . Please make sure to install the correct version for the OS you are running. 1. Open a new terminal ( guide ). 2. The downloaded installer zip file should be in your Downloads folder. You can navigate to this folder by entering the following command in your terminal: cd ~/Downloads 3. You should now be able to see the installer .zip file, if you run the following command: ls 4. To unzip the installer, run the following command (this may take a second): unzip <zip_file_name> For example: unzip stm32cubemx-lin-v6-16-0.zip 5. You should now be able to see the installer executable along with Readme.html and a Java runtime by running the following command: ls 6. Run the installer by running the following (you may be prompted to enter your password): sudo ./SetupSTM32CubeMX-<version> For example: sudo ./SetupSTM32CubeMX-6.16.0 7. In the UI that opens, select Next and accept the License and Terms of Use. 8. Select an appropriate installation directory (we recommend /usr/local/STMicroelectronics/STM32Cube/STM32CubeMX ) 9. Once the installation completes, select Done . 10. To clean the installation, remove all files in ~/Downloads from the installer with the following: rm -rf jre Readme.html SetupSTM32CubeMX* stm32cubemx-lin-*.zip 11. To use STM32CubeMX from the command line, it must be first added to the system path. To do this, we will use vi ( guide ). Run the following command: sudo vi /etc/environment And append your installation directory (for example, /usr/local/STMicroelectronics/STM32Cube/STM32CubeMX ) to PATH , separated from the other paths by a : . 12. Reboot your machine, open a terminal, and verify that the following command can find STM32CubeMX (it should output the path used in step 11): which STM32CubeMX Downloading and Installing CubeCLT 1. Download CubeCLT Go to the CubeCLT download page and scroll down to \"Get Software.\" For this walkthrough, we will be using the Debian Linux installer for UBUNTU USERS. Click on \"Select Version\", then select the newest version for the correct OS you are running!!! Click on Accept for the License Agreement pop up. You will then be prompted to log in, create an account, or continue as a guest. You will need a MyST account in the future, so it is best to create one now. You may use any email address. After logging in and being brought back to the download page, the download should start automatically. Scroll down and select the correct version from \"Get Software\" if it does not. 2. Install CubeCLT Note : This install guide is for Debian Linux . Please make sure to install the correct version for the OS you are running. 1. Open a new terminal ( guide ). 2. The downloaded installer zip file should be in your Downloads folder. You can navigate to this folder by entering the following command in your terminal: cd ~/Downloads 3. You should now be able to see the installer .zip file, if you run the following command: ls 4. To unzip the installer, run the following command (this may take a second): unzip <zip_file_name> For example: unzip st-stm32cubeclt_1.20.0_26822_20251117_1245_amd64.deb_bundle.sh.zip 5. You should now be able to see the installer script by running the following command: ls 6. Run the installer by running the following (you may be prompted to enter your password): sudo chomd +x <script> sudo ./<script> For example: sudo chmod +x st-stm32cubeclt_1.20.0_26822_20251117_1245_amd64.deb_bundle.sh sudo ./st-stm32cubeclt_1.20.0_26822_20251117_1245_amd64.deb_bundle.sh 7. Accept the License Agreement ( y and then Enter ). 8. To clean the installation, remove all files in ~/Downloads from the installer with the following: rm st-stm32cubeclt* 9. To be able to use the various STM32CubeCLT components, add them all to path as was done with CubeMX. The install path to STM32CubeCLT is /opt/st/ , but each tool included has its own bin directory that must be added to the path independently. The tools to be added are as follows. GNU-tools-for-STM32 st-arm-clang STLink-gdb-server STM32CubeProgrammer CubeMX and CubeCLT for macOS Users 1. Download Download STM32CubeCLT and STM32CubeMX for macOS. By default your Downloads folder should now contain two tar files, one for each tool. 2. Install Double click on each tar file. One tar file will expand into a .app bundle: double click this item and follow the installation steps. The other tar file should expand into a folder with two .pkg files: click on each one respectively and follow the steps for installation. 3. Update your PATH The scripts/new.sh script (used when creating a new project ) needs to know where the STM32CubeMX and STM32CubeCLT binaries exist, which we can specify by adding the location of the binaries to our PATH environment variable . There are multiple ways to do this, but the way we will choose is to add the paths to the system-wide /etc/paths file: Run the command sudo nano /etc/paths to open a text editor in the terminal where we can update this file. Ensure that all the following paths exist in the file. If a path is missing, type it in on a new line. Once you are done, make sure you write out ( ^O ) and exit ( ^X ). Restart your terminal. Ensure the paths you added have been added to your PATH environment variable by running the command echo $PATH . You should see all the paths you added somewhere in the output. 4. Next Steps You should now be able to create a new project following the steps below . Creating a New Project This quick guide will teach you how to make a new project for your STM32G431RB Nucleo board that you will be developing on. Prerequisites STM32CubeMX and STM32CubeCLT installed Guide To create a new project, use the scripts/new.sh script. The script accepts either an MCU or Development Board ID, project source, and optionally any number of cmake libraries defined under lib . To create a project for the Nucleo G431RB developer kit, run the following. ./scripts/new.sh --board NUCLEO-G431RB --src <path/to/project> When prompted to select default peripheral configurations, select \"Unselect All\" and \"continue\". If this is the first time STM32CubeMX is being run on a machine, it may need to download the firmware repository. Select \"Download\" and continue. Once the script completes, try to build the generated project as follows. ./scripts/build.sh --src <path/to/project> If this completes successfully, then STM32CubeCLT is correctly installed on the system. Open the <project>.ioc file in STM32CubeMX to modify the project configuration. Congratulations! You have successfully created a new project with CubeMX!","title":"STM32Cube"},{"location":"getting-started/stm32cube/#stm32cube","text":"","title":"STM32Cube*"},{"location":"getting-started/stm32cube/#about","text":"STM32CubeMX and STM32CubeCLT allow the user to write, compile, and flash code to the STM32 microcontroller! STM32CubeCLT contains the GCC compiler and GDB debugging tool for firmware compilation and debugging, and STM32CubeMX contains the interface for configuring the microcontroller and project environment, and provides a very powerful interface for automatic code generation, allowing the user to initialize an entire module with a few clicks of a button, and have that code show up automatically in the main file. Note If you've taken EECS 373, you have used STM32CubeIDE, which is an IDE that packages both of these tools together. However, STM32CubeIDE is a very heavy program, so we choose to use the lighter weight STM32CubeMX and STM32CubeCLT tools in combination with CMake and your favorite text editor or IDE.","title":"About"},{"location":"getting-started/stm32cube/#downloading-and-installing-cubemx","text":"","title":"Downloading and Installing CubeMX"},{"location":"getting-started/stm32cube/#1-download-cubemx","text":"Go to the CubeMX download page and scroll down to \"Get Software.\" For this walkthrough, we will be using the Linux installer for UBUNTU USERS. Click on \"Select Version\", then select the newest version for the correct OS you are running!!! Click on Accept for the License Agreement pop up. You will then be prompted to log in, create an account, or continue as a guest. You will need a MyST account in the future, so it is best to create one now. You may use any email address. After logging in and being brought back to the download page, the download should start automatically. Scroll down and select the correct version from \"Get Software\" if it does not.","title":"1. Download CubeMX"},{"location":"getting-started/stm32cube/#2-install-cubemx","text":"Note : This install guide is for Linux . Please make sure to install the correct version for the OS you are running. 1. Open a new terminal ( guide ). 2. The downloaded installer zip file should be in your Downloads folder. You can navigate to this folder by entering the following command in your terminal: cd ~/Downloads 3. You should now be able to see the installer .zip file, if you run the following command: ls 4. To unzip the installer, run the following command (this may take a second): unzip <zip_file_name> For example: unzip stm32cubemx-lin-v6-16-0.zip 5. You should now be able to see the installer executable along with Readme.html and a Java runtime by running the following command: ls 6. Run the installer by running the following (you may be prompted to enter your password): sudo ./SetupSTM32CubeMX-<version> For example: sudo ./SetupSTM32CubeMX-6.16.0 7. In the UI that opens, select Next and accept the License and Terms of Use. 8. Select an appropriate installation directory (we recommend /usr/local/STMicroelectronics/STM32Cube/STM32CubeMX ) 9. Once the installation completes, select Done . 10. To clean the installation, remove all files in ~/Downloads from the installer with the following: rm -rf jre Readme.html SetupSTM32CubeMX* stm32cubemx-lin-*.zip 11. To use STM32CubeMX from the command line, it must be first added to the system path. To do this, we will use vi ( guide ). Run the following command: sudo vi /etc/environment And append your installation directory (for example, /usr/local/STMicroelectronics/STM32Cube/STM32CubeMX ) to PATH , separated from the other paths by a : . 12. Reboot your machine, open a terminal, and verify that the following command can find STM32CubeMX (it should output the path used in step 11): which STM32CubeMX","title":"2. Install CubeMX"},{"location":"getting-started/stm32cube/#downloading-and-installing-cubeclt","text":"","title":"Downloading and Installing CubeCLT"},{"location":"getting-started/stm32cube/#1-download-cubeclt","text":"Go to the CubeCLT download page and scroll down to \"Get Software.\" For this walkthrough, we will be using the Debian Linux installer for UBUNTU USERS. Click on \"Select Version\", then select the newest version for the correct OS you are running!!! Click on Accept for the License Agreement pop up. You will then be prompted to log in, create an account, or continue as a guest. You will need a MyST account in the future, so it is best to create one now. You may use any email address. After logging in and being brought back to the download page, the download should start automatically. Scroll down and select the correct version from \"Get Software\" if it does not.","title":"1. Download CubeCLT"},{"location":"getting-started/stm32cube/#2-install-cubeclt","text":"Note : This install guide is for Debian Linux . Please make sure to install the correct version for the OS you are running. 1. Open a new terminal ( guide ). 2. The downloaded installer zip file should be in your Downloads folder. You can navigate to this folder by entering the following command in your terminal: cd ~/Downloads 3. You should now be able to see the installer .zip file, if you run the following command: ls 4. To unzip the installer, run the following command (this may take a second): unzip <zip_file_name> For example: unzip st-stm32cubeclt_1.20.0_26822_20251117_1245_amd64.deb_bundle.sh.zip 5. You should now be able to see the installer script by running the following command: ls 6. Run the installer by running the following (you may be prompted to enter your password): sudo chomd +x <script> sudo ./<script> For example: sudo chmod +x st-stm32cubeclt_1.20.0_26822_20251117_1245_amd64.deb_bundle.sh sudo ./st-stm32cubeclt_1.20.0_26822_20251117_1245_amd64.deb_bundle.sh 7. Accept the License Agreement ( y and then Enter ). 8. To clean the installation, remove all files in ~/Downloads from the installer with the following: rm st-stm32cubeclt* 9. To be able to use the various STM32CubeCLT components, add them all to path as was done with CubeMX. The install path to STM32CubeCLT is /opt/st/ , but each tool included has its own bin directory that must be added to the path independently. The tools to be added are as follows. GNU-tools-for-STM32 st-arm-clang STLink-gdb-server STM32CubeProgrammer","title":"2. Install CubeCLT"},{"location":"getting-started/stm32cube/#cubemx-and-cubeclt-for-macos-users","text":"","title":"CubeMX and CubeCLT for macOS Users"},{"location":"getting-started/stm32cube/#1-download","text":"Download STM32CubeCLT and STM32CubeMX for macOS. By default your Downloads folder should now contain two tar files, one for each tool.","title":"1. Download"},{"location":"getting-started/stm32cube/#2-install","text":"Double click on each tar file. One tar file will expand into a .app bundle: double click this item and follow the installation steps. The other tar file should expand into a folder with two .pkg files: click on each one respectively and follow the steps for installation.","title":"2. Install"},{"location":"getting-started/stm32cube/#3-update-your-path","text":"The scripts/new.sh script (used when creating a new project ) needs to know where the STM32CubeMX and STM32CubeCLT binaries exist, which we can specify by adding the location of the binaries to our PATH environment variable . There are multiple ways to do this, but the way we will choose is to add the paths to the system-wide /etc/paths file: Run the command sudo nano /etc/paths to open a text editor in the terminal where we can update this file. Ensure that all the following paths exist in the file. If a path is missing, type it in on a new line. Once you are done, make sure you write out ( ^O ) and exit ( ^X ). Restart your terminal. Ensure the paths you added have been added to your PATH environment variable by running the command echo $PATH . You should see all the paths you added somewhere in the output.","title":"3. Update your PATH"},{"location":"getting-started/stm32cube/#4-next-steps","text":"You should now be able to create a new project following the steps below .","title":"4. Next Steps"},{"location":"getting-started/stm32cube/#creating-a-new-project","text":"This quick guide will teach you how to make a new project for your STM32G431RB Nucleo board that you will be developing on.","title":"Creating a New Project"},{"location":"getting-started/stm32cube/#prerequisites","text":"STM32CubeMX and STM32CubeCLT installed","title":"Prerequisites"},{"location":"getting-started/stm32cube/#guide","text":"To create a new project, use the scripts/new.sh script. The script accepts either an MCU or Development Board ID, project source, and optionally any number of cmake libraries defined under lib . To create a project for the Nucleo G431RB developer kit, run the following. ./scripts/new.sh --board NUCLEO-G431RB --src <path/to/project> When prompted to select default peripheral configurations, select \"Unselect All\" and \"continue\". If this is the first time STM32CubeMX is being run on a machine, it may need to download the firmware repository. Select \"Download\" and continue. Once the script completes, try to build the generated project as follows. ./scripts/build.sh --src <path/to/project> If this completes successfully, then STM32CubeCLT is correctly installed on the system. Open the <project>.ioc file in STM32CubeMX to modify the project configuration. Congratulations! You have successfully created a new project with CubeMX!","title":"Guide"},{"location":"info/brushed/","text":"Brushed DC Motors We used brushed DC motors for various mechanisms on our rover. For example, on our robotic arm, we use a 24V brushed motor for joint B and a 12V brushed motor for the gripper. Current information about our brushed motor controller (BMC) can be found on the ESW Google Drive in projects/brushed-motor-controller-26 ( link ).","title":"Brushed Motors"},{"location":"info/brushed/#brushed-dc-motors","text":"We used brushed DC motors for various mechanisms on our rover. For example, on our robotic arm, we use a 24V brushed motor for joint B and a 12V brushed motor for the gripper. Current information about our brushed motor controller (BMC) can be found on the ESW Google Drive in projects/brushed-motor-controller-26 ( link ).","title":"Brushed DC Motors"},{"location":"info/brushless/","text":"Brushless DC Motors","title":"Brushless Motors"},{"location":"info/brushless/#brushless-dc-motors","text":"","title":"Brushless DC Motors"},{"location":"info/cmake-tools/","text":"CMake + CubeMX/CubeCLT Toolchain Installing Install CubeMX . This is the .ioc file editor. Install CubeCLT . This is the command-line toolset that contains all the software necessary to build and deploy the codebase. Install CubeMCUFinder . Install the corresponding extension for your editor. In each case, the extension will need to be provided the location to CubeMX and CubeCLT. CLion VS Code Creating a New CubeMX Project Open CubeMX and navigate to File \u2192 New Project . A window should pop up. In this window, select your desired MCU or development board. To search, use the \"Commercial Part Number\" search bar. When you have selected your MCU/board, click Start Project in the top right. Navigate to the Project Manager tab. Give your project a name and set the Project Location to the desired directory. Set the Toolchain / IDE dropdown to CMake . Now, still in the Project Manager tab, navigate to the Code Generator settings on the left menu. Select Copy only the necessary library files . This will reduce bloat on your computer by only bringing in the necessary HAL files for your specific project instead of all 900+. Save the project by navigating to File \u2192 Save Project or by pressing Ctrl + S . Click Generate Code in the top right. CubeMX will generate the project files in the specified directory. For example, if the project name is myproject and the location is /home/user/mrover-esw/src/ , the generated files will be in /home/user/mrover-esw/src/myproject/ . Adding CMake Dependencies to Projects Removing Dependency on Generated HAL Drivers By default, CubeMX generates HAL drivers and includes them in the project. The top level CMakeLists.txt then includes these generated HAL drivers in the build with the following line: add_subdirectory(cmake/stm32cubemx) If you take a look inside the CMakeLists.txt inside the cmake/stm32cubemx/ directory, you will see that it includes all of the generated HAL drivers for the selected MCU. This CMakeLists.txt is automatically generated by CubeMX to include the necessary HAL drivers your project requires. For example: set(STM32_Drivers_Src ${CMAKE_CURRENT_SOURCE_DIR}/../../Core/Src/system_stm32g4xx.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ramfunc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_gpio.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_exti.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_cortex.c ) These generated HAL drivers total over 900 files, which is unnecessary and would bloat the repository if committed. In order to prevent this, we remove the dependency on the generated HAL drivers for each project and instead use a shared HAL driver library which is hosted as a git submodule in lib/extern/STM32CubeG4 . To do this, we create our own CMakeLists.txt file in a new directory cmake/stm32cubemx_extern/ . This CMakeLists.txt file will replace the generated one and instead link to the shared HAL driver library. For example, the above generated CMakeLists.txt would be replaced with the following: set(STM32_Drivers_Src ${CMAKE_CURRENT_SOURCE_DIR}/../../Core/Src/system_stm32g4xx.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ramfunc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_gpio.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_exti.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_cortex.c ) You can see that instead of navigating to the Drivers/STM32G4xx_HAL_Driver/ directory that is autogenerated for every project, we instead navigate to the shared HAL driver library in lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/ . To use this new CMakeLists.txt file instead of the autogenerated one, simply replace the following line in the top-level CMakeLists.txt: add_subdirectory(cmake/stm32cubemx) with add_subdirectory(cmake/stm32cubemx_extern) Keep in mind that whenever you generate code from CubeMX which requires a new HAL driver file, you will need to manually add that file to the cmake/stm32cubemx_extern/CMakeLists.txt file. For example, if you enable the I2C peripheral in CubeMX and regenerate code, CubeMX will generate the file stm32g4xx_hal_i2c.c . You will then need to add the following line to the cmake/stm32cubemx_extern/CMakeLists.txt file where the other HAL driver files are listed: ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_i2c.c TODO We should create a script to automate this process of creating and updating the cmake/stm32cubemx_extern/CMakeLists.txt file. Adding lib/ Dependencies To add lib/ dependencies to a CubeMX project, add the following to CMakeLists.txt . # Add fwlib dependency add_subdirectory(../../lib fwlib) # Add linked libraries target_link_libraries(${CMAKE_PROJECT_NAME} stm32cubemx # Add user defined libraries stm32 units util ) Building and Flashing ./scripts/build.sh --src <PROJECT> will build the project ./scripts/flash.sh --src <PROJECT> will flash the project to the MCU connected to the STLINK For example, if the project is named myproject and is located in /home/user/mrover-esw/src/ , the command to build would be: ./scripts/build.sh --src myproject Note In order to use the scripts to build and flash, ensure all */bin directories from CubeCLT are included in $PATH","title":"CMake Toolchain"},{"location":"info/cmake-tools/#cmake-cubemxcubeclt-toolchain","text":"","title":"CMake + CubeMX/CubeCLT Toolchain"},{"location":"info/cmake-tools/#installing","text":"Install CubeMX . This is the .ioc file editor. Install CubeCLT . This is the command-line toolset that contains all the software necessary to build and deploy the codebase. Install CubeMCUFinder . Install the corresponding extension for your editor. In each case, the extension will need to be provided the location to CubeMX and CubeCLT. CLion VS Code","title":"Installing"},{"location":"info/cmake-tools/#creating-a-new-cubemx-project","text":"Open CubeMX and navigate to File \u2192 New Project . A window should pop up. In this window, select your desired MCU or development board. To search, use the \"Commercial Part Number\" search bar. When you have selected your MCU/board, click Start Project in the top right. Navigate to the Project Manager tab. Give your project a name and set the Project Location to the desired directory. Set the Toolchain / IDE dropdown to CMake . Now, still in the Project Manager tab, navigate to the Code Generator settings on the left menu. Select Copy only the necessary library files . This will reduce bloat on your computer by only bringing in the necessary HAL files for your specific project instead of all 900+. Save the project by navigating to File \u2192 Save Project or by pressing Ctrl + S . Click Generate Code in the top right. CubeMX will generate the project files in the specified directory. For example, if the project name is myproject and the location is /home/user/mrover-esw/src/ , the generated files will be in /home/user/mrover-esw/src/myproject/ .","title":"Creating a New CubeMX Project"},{"location":"info/cmake-tools/#adding-cmake-dependencies-to-projects","text":"","title":"Adding CMake Dependencies to Projects"},{"location":"info/cmake-tools/#removing-dependency-on-generated-hal-drivers","text":"By default, CubeMX generates HAL drivers and includes them in the project. The top level CMakeLists.txt then includes these generated HAL drivers in the build with the following line: add_subdirectory(cmake/stm32cubemx) If you take a look inside the CMakeLists.txt inside the cmake/stm32cubemx/ directory, you will see that it includes all of the generated HAL drivers for the selected MCU. This CMakeLists.txt is automatically generated by CubeMX to include the necessary HAL drivers your project requires. For example: set(STM32_Drivers_Src ${CMAKE_CURRENT_SOURCE_DIR}/../../Core/Src/system_stm32g4xx.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ramfunc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_gpio.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_exti.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr.c ${CMAKE_CURRENT_SOURCE_DIR}/../../Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_cortex.c ) These generated HAL drivers total over 900 files, which is unnecessary and would bloat the repository if committed. In order to prevent this, we remove the dependency on the generated HAL drivers for each project and instead use a shared HAL driver library which is hosted as a git submodule in lib/extern/STM32CubeG4 . To do this, we create our own CMakeLists.txt file in a new directory cmake/stm32cubemx_extern/ . This CMakeLists.txt file will replace the generated one and instead link to the shared HAL driver library. For example, the above generated CMakeLists.txt would be replaced with the following: set(STM32_Drivers_Src ${CMAKE_CURRENT_SOURCE_DIR}/../../Core/Src/system_stm32g4xx.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_rcc_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_flash_ramfunc.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_gpio.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_exti.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_dma_ex.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_pwr.c ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_cortex.c ) You can see that instead of navigating to the Drivers/STM32G4xx_HAL_Driver/ directory that is autogenerated for every project, we instead navigate to the shared HAL driver library in lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/ . To use this new CMakeLists.txt file instead of the autogenerated one, simply replace the following line in the top-level CMakeLists.txt: add_subdirectory(cmake/stm32cubemx) with add_subdirectory(cmake/stm32cubemx_extern) Keep in mind that whenever you generate code from CubeMX which requires a new HAL driver file, you will need to manually add that file to the cmake/stm32cubemx_extern/CMakeLists.txt file. For example, if you enable the I2C peripheral in CubeMX and regenerate code, CubeMX will generate the file stm32g4xx_hal_i2c.c . You will then need to add the following line to the cmake/stm32cubemx_extern/CMakeLists.txt file where the other HAL driver files are listed: ${CMAKE_CURRENT_SOURCE_DIR}/../../../../lib/extern/STM32CubeG4/Drivers/STM32G4xx_HAL_Driver/Src/stm32g4xx_hal_i2c.c TODO We should create a script to automate this process of creating and updating the cmake/stm32cubemx_extern/CMakeLists.txt file.","title":"Removing Dependency on Generated HAL Drivers"},{"location":"info/cmake-tools/#adding-lib-dependencies","text":"To add lib/ dependencies to a CubeMX project, add the following to CMakeLists.txt . # Add fwlib dependency add_subdirectory(../../lib fwlib) # Add linked libraries target_link_libraries(${CMAKE_PROJECT_NAME} stm32cubemx # Add user defined libraries stm32 units util )","title":"Adding lib/ Dependencies"},{"location":"info/cmake-tools/#building-and-flashing","text":"./scripts/build.sh --src <PROJECT> will build the project ./scripts/flash.sh --src <PROJECT> will flash the project to the MCU connected to the STLINK For example, if the project is named myproject and is located in /home/user/mrover-esw/src/ , the command to build would be: ./scripts/build.sh --src myproject Note In order to use the scripts to build and flash, ensure all */bin directories from CubeCLT are included in $PATH","title":"Building and Flashing"},{"location":"info/nucleos/","text":"Nucleos Introduction A \u201cNucleo\u201d is a microcontroller evaluation board manufactured by STM32 to prototype with STM32\u2019s MCUs. Nucleos come with a removable ST-Link debugger/programmer integrated on the board, allowing firmware flashing and extensive debugging options through a simple USB connection. STM32 MCU have a wide range of hardware capabilities, with dedicated internal circuitry for I2C, SPI, UART, timers, and more. Firmware is typically written in C/C++ using STM32\u2019s extremely capable Hardware Abstraction Layer (HAL) libraries, and compiled in STM32\u2019s Cube IDE. MCU STM32 microcontrollers are organized into various categories, as shown. Each family of MCUs has dozens of models, each with a different feature set. The MCU\u2019s are a realization of ARM\u2019s Cortex M family of processors. Use the product selector on ST\u2019s website to find MCU\u2019s appropriate to your application. Nucleo STM32 Nucleos are evaluation boards available to prototype designs that employ STM32 MCUs. There are many models of Nucleos, named after the MCU installed, the physical form factor, and the flash memory size. All available Nucleo boards are shown below. Nucleos are often cheap (~$10 for a Nucleo-F303RE). The board breaks out all the MCU\u2019s available interfaces into header pins, while implementing most of the standard extraneous circuity (voltage regulators, oscillators, etc.) required by the MCU. Designed for prototyping/testing, Nucleos come with an ST-Link debugger/programmer module, which will automatically flash the MCU\u2019s firmware and allows the Cube IDE to debug code mid-execution. It is important to note that the essential component is the MCU itself - a Nucleo is just a helpful breakout board that ST has provided for select MCUs. Many topics discussed below, such as HAL/LL Libraries, interrupts, and interface peripherals, are elements of the MCU, not the Nucleo. A notable exception is the ST-Link programmer/debugger. This guide is very intentional with its use of the term \"MCU\" vs \"Nucleo\" Cube IDE ST\u2019s Cube IDE is built off of the Eclipse IDE. Upon creating a new \u201cSTM32 Project\u201d, the IDE will prompt the user to select a STM32 MCU. The IDE should automatically preload all relevant HAL libraries (discussed later) into the project workspace and generate the proper initialization code. A .ioc file is also generated, which when viewed in ST\u2019s custom \u201cDevice Configuation Tool\u201d perspective, allows the user to interactively control various features of the MCU. An example of this perspective is shown below. CubeIDE will use the settings specified in the .ioc file to automatically generate code for the STM32\u2019s firmware. STM32 processors typically use no operating system, and such behave much like an Arduino. At a basic level, their functionality is to run the main.c code that is flashed to their memory. Cube IDE will populate the main.c with the standard set of code necessary to get the MCU started. (RTOS is an option, but MRover firmware shouldn\u2019t be complex enough to necessitate RTOS) In reality, the STM32 MCU is flashed with a binary file containing machine code. CubeIDE uses g++ to compile C/C++ code, automatically passing g++ the appropriate instruction set (in this case, ARM Cortex instruction sets). ArduinoIDE does the same, using a C compiler to flash Arduinos with machine code. Developers typically never see the machine code, as the programming languages make a point of abstracting ISAs (instruction set architectures) away from the higher-level logic/structures programmers wish to deal with. Changing the MCU configuration in the device configuration tool should ask the developer whether or not to \u201cGenerate Code?\u201d Select yes, because this will prompt CubeIDE to regenerate the code necessary to set up the MCU as desired. CubeIDE often uses HAL functions or rarely LL functions to accomplish this, and will clearly mark all the pregenerated code with comments. STM32 Libraries HAL stands for Hardware Abstraction Layer. It is a library written by ST, available from Cube IDE, that provides interface functions that will control the STM32 MCU\u2019s hardware. By abstracting away the MCU model-specific details of hardware control, code using HAL functions should be easily ported between STM32 MCU\u2019s within the same lineup. For example, the entire STM32F4 series of MCU\u2019s are controlled using the same HAL library. HAL functions will do runtime checks for hardware faults. For example, if the I2C module of the MCU is locked in an inoperable state, the next I2C related HAL function will detect the issue. LL (Low-level) APIs are also available. They are a fast, light-weight, closer-to-hardware layer that developers can use to control the MCU hardware. They are, however, meant for embedded system experts, and it recommended the MCU hardware be entirely controlled by HAL functions. HAL and LL functions are documented thoroughly but shallowly. What this means is that the documentation definitely contains and explains every HAL/LL function that exists, but only brief, high-level explanations are provided. There is the assumption that STM32 developers understand coding principles such as callbacks and interrupts. There is also the expectation that STM32 developers are familiar with the interface peripherals they are controlling. ST-Link The USB connection on the Nucleo is actually a connection to the removable section of the board called the ST-Link. The ST-Link is able to flash firmware to the MCU, and control debugging related interface peripherals on the MCU. Removal of the ST-Link also removes the capability to do firmware flashing and live debugging through USB. ST-Link's are also available as a seperate piece of hardware, if a developer desires the ST-Link flashing/debugging experience with STM32 MCUs that aren't embedded into a Nucleo. ST has written the USB drivers for the ST-Link in a clever way. Upon connecting an ST-Link to a computer through USB, the ST-Link will appear as an external hard drive to the computer. The most basic way to flash an STM32 MCU with firmware is to copy the firmware compiled as a binary file into this \u201cexternal hard drive\u201d. The ST-Link will automatically flash the MCU with the binary, and the MCU begins executing the binary once complete. A more streamlined way to flash code to the STM32 MCU is through CubeIDE. There is, of course, the standard \u201cbuild\u201d button that most C++ IDE\u2019s have \u2013 responsible for compiling the main.c, main.h, other developer-written files, and necessary HAL functions into a single executable. CubeIDE also has a \u201cdebug\u201d button, which will build the executable and also send it directly to the ST-Link connected to the computer at the moment. Using this function will also connect the CubeIDE to all the ST-Link\u2019s debugging functionalities. This way, the MCU is controllable through CubeIDE with standard debugging steps. This includes pausing at breakpoints, stepping forward, stepping in, stepping out, continuing, etc\u2026 Debugging a STM32 MCU with active interface peripherals is dangerous, however \u2013 there is a good chance that the interface peripheral will enter faulty states because the MCU is not operating with normal execution flows. Note that there are two build options \u2013 debug and release. Debug builds are more helpful when debugging, and release builds are optimized for speed \u2013 up to several orders of magnitude faster. It is helpful to, in CubeIDE, follow these steps: 1. Open \"Properties\" from the \"Project\" dropdown menu at the top of the screen. 2. Open \"C/C++ Build\" > \"Settings\" from the lefthand navigation menu. 3. Select \"Debug\" for the Configuration option 4. Select the \"Tool Settings\" tab. 5. Select \"MCU Post build outputs\" from the lefthand navigation menu 6. Check the \"Convert to binary file\" option 7. Select \"Release\" for the Configuration option 8. Repeat steps 4-6 This will ensure CubeIDE always generates a single machine code binary for developer use within the project directory whenever the project is built. They will be located in the \"Debug\" or \"Release\" folders, depending on which type of build is used. The .bin file is a complete copy of the firmware for the STM32 MCU - it can be moved, saved, shared, as any normal file, as well as copied into the ST-Link's pretend \"External Drive\" to flash the STM32 MCU, independent of CubeIDE. Callbacks and Interrupts An interrupt is a signal that interrupts the natural flow of a program. This is typically done at a processor level, so interrupts can cause breakaways from practically anywhere in the code. When interrupts trigger, they force the processor to execute a separate segment of code. Only when that segment finishes, does the processor return to where it left off with the original program. HAL functions accomplish a lot of their functionality through callback functions. Callback functions are functions that are \u201cto be called back later\u201d. Interrupts generated by interface peripherals will typically call a callback function, pausing the main execution flow of the program to handle the event generated by the interrupt. For example, if a hardware counter unit on the STM32 MCU is configured to be a timer that generates an interrupt every second \u2013 every second, the hardware counter unit will signal to the processor to stop what it\u2019s doing (perhaps the processor is just waiting in a \u201cwhile true\u201d loop). The processor will enter the callback function labeled HAL_TIM_Callback(), expecting this function has been written to handle what should happen when this timer gives it\u2019s signal. Once that callback function finishes, the processor returns to its \u201cwhile true\u201d loop. Callback functions are \u201cweakly\u201d defined by the HAL \u2013 as soon as the developer redefines the function, the HAL callback function (which is just a placeholder and is functionally empty) is overwritten. This simple method of redefining HAL callback functions is an easy way for developers to write code that responds to events generated by the MCU\u2019s interface peripherals. The HAL documentation lists all the callback functions that can be overwritten. Interface Peripherals Interface peripherals refer broadly to the interfaces onboard the STM32 MCU. These are often implemented in hardware, not software. For example, below is a block diagram for the I2C interface on almost all STM32 F3 series MCU\u2019s. Hardware implemented interfaces have a number of advantages * They don't require processor cycles to operate * They use system clocks and their own state registers, isolating their performance from the rest of the MCU * They only trigger interrupts when meaningful events happen Controlling hardware interface peripherals typically involves writing to and reading from control registers. HAL/LL functions take care of this, abstracting the hardware away from the interfacing. Most interface peripherals can be controlled entirely through HAL functions, though the control registers can be read/written by a developer if necessary.","title":"Nucleo Information"},{"location":"info/nucleos/#nucleos-introduction","text":"A \u201cNucleo\u201d is a microcontroller evaluation board manufactured by STM32 to prototype with STM32\u2019s MCUs. Nucleos come with a removable ST-Link debugger/programmer integrated on the board, allowing firmware flashing and extensive debugging options through a simple USB connection. STM32 MCU have a wide range of hardware capabilities, with dedicated internal circuitry for I2C, SPI, UART, timers, and more. Firmware is typically written in C/C++ using STM32\u2019s extremely capable Hardware Abstraction Layer (HAL) libraries, and compiled in STM32\u2019s Cube IDE.","title":"Nucleos Introduction"},{"location":"info/nucleos/#mcu","text":"STM32 microcontrollers are organized into various categories, as shown. Each family of MCUs has dozens of models, each with a different feature set. The MCU\u2019s are a realization of ARM\u2019s Cortex M family of processors. Use the product selector on ST\u2019s website to find MCU\u2019s appropriate to your application.","title":"MCU"},{"location":"info/nucleos/#nucleo","text":"STM32 Nucleos are evaluation boards available to prototype designs that employ STM32 MCUs. There are many models of Nucleos, named after the MCU installed, the physical form factor, and the flash memory size. All available Nucleo boards are shown below. Nucleos are often cheap (~$10 for a Nucleo-F303RE). The board breaks out all the MCU\u2019s available interfaces into header pins, while implementing most of the standard extraneous circuity (voltage regulators, oscillators, etc.) required by the MCU. Designed for prototyping/testing, Nucleos come with an ST-Link debugger/programmer module, which will automatically flash the MCU\u2019s firmware and allows the Cube IDE to debug code mid-execution. It is important to note that the essential component is the MCU itself - a Nucleo is just a helpful breakout board that ST has provided for select MCUs. Many topics discussed below, such as HAL/LL Libraries, interrupts, and interface peripherals, are elements of the MCU, not the Nucleo. A notable exception is the ST-Link programmer/debugger. This guide is very intentional with its use of the term \"MCU\" vs \"Nucleo\"","title":"Nucleo"},{"location":"info/nucleos/#cube-ide","text":"ST\u2019s Cube IDE is built off of the Eclipse IDE. Upon creating a new \u201cSTM32 Project\u201d, the IDE will prompt the user to select a STM32 MCU. The IDE should automatically preload all relevant HAL libraries (discussed later) into the project workspace and generate the proper initialization code. A .ioc file is also generated, which when viewed in ST\u2019s custom \u201cDevice Configuation Tool\u201d perspective, allows the user to interactively control various features of the MCU. An example of this perspective is shown below. CubeIDE will use the settings specified in the .ioc file to automatically generate code for the STM32\u2019s firmware. STM32 processors typically use no operating system, and such behave much like an Arduino. At a basic level, their functionality is to run the main.c code that is flashed to their memory. Cube IDE will populate the main.c with the standard set of code necessary to get the MCU started. (RTOS is an option, but MRover firmware shouldn\u2019t be complex enough to necessitate RTOS) In reality, the STM32 MCU is flashed with a binary file containing machine code. CubeIDE uses g++ to compile C/C++ code, automatically passing g++ the appropriate instruction set (in this case, ARM Cortex instruction sets). ArduinoIDE does the same, using a C compiler to flash Arduinos with machine code. Developers typically never see the machine code, as the programming languages make a point of abstracting ISAs (instruction set architectures) away from the higher-level logic/structures programmers wish to deal with. Changing the MCU configuration in the device configuration tool should ask the developer whether or not to \u201cGenerate Code?\u201d Select yes, because this will prompt CubeIDE to regenerate the code necessary to set up the MCU as desired. CubeIDE often uses HAL functions or rarely LL functions to accomplish this, and will clearly mark all the pregenerated code with comments.","title":"Cube IDE"},{"location":"info/nucleos/#stm32-libraries","text":"HAL stands for Hardware Abstraction Layer. It is a library written by ST, available from Cube IDE, that provides interface functions that will control the STM32 MCU\u2019s hardware. By abstracting away the MCU model-specific details of hardware control, code using HAL functions should be easily ported between STM32 MCU\u2019s within the same lineup. For example, the entire STM32F4 series of MCU\u2019s are controlled using the same HAL library. HAL functions will do runtime checks for hardware faults. For example, if the I2C module of the MCU is locked in an inoperable state, the next I2C related HAL function will detect the issue. LL (Low-level) APIs are also available. They are a fast, light-weight, closer-to-hardware layer that developers can use to control the MCU hardware. They are, however, meant for embedded system experts, and it recommended the MCU hardware be entirely controlled by HAL functions. HAL and LL functions are documented thoroughly but shallowly. What this means is that the documentation definitely contains and explains every HAL/LL function that exists, but only brief, high-level explanations are provided. There is the assumption that STM32 developers understand coding principles such as callbacks and interrupts. There is also the expectation that STM32 developers are familiar with the interface peripherals they are controlling.","title":"STM32 Libraries"},{"location":"info/nucleos/#st-link","text":"The USB connection on the Nucleo is actually a connection to the removable section of the board called the ST-Link. The ST-Link is able to flash firmware to the MCU, and control debugging related interface peripherals on the MCU. Removal of the ST-Link also removes the capability to do firmware flashing and live debugging through USB. ST-Link's are also available as a seperate piece of hardware, if a developer desires the ST-Link flashing/debugging experience with STM32 MCUs that aren't embedded into a Nucleo. ST has written the USB drivers for the ST-Link in a clever way. Upon connecting an ST-Link to a computer through USB, the ST-Link will appear as an external hard drive to the computer. The most basic way to flash an STM32 MCU with firmware is to copy the firmware compiled as a binary file into this \u201cexternal hard drive\u201d. The ST-Link will automatically flash the MCU with the binary, and the MCU begins executing the binary once complete. A more streamlined way to flash code to the STM32 MCU is through CubeIDE. There is, of course, the standard \u201cbuild\u201d button that most C++ IDE\u2019s have \u2013 responsible for compiling the main.c, main.h, other developer-written files, and necessary HAL functions into a single executable. CubeIDE also has a \u201cdebug\u201d button, which will build the executable and also send it directly to the ST-Link connected to the computer at the moment. Using this function will also connect the CubeIDE to all the ST-Link\u2019s debugging functionalities. This way, the MCU is controllable through CubeIDE with standard debugging steps. This includes pausing at breakpoints, stepping forward, stepping in, stepping out, continuing, etc\u2026 Debugging a STM32 MCU with active interface peripherals is dangerous, however \u2013 there is a good chance that the interface peripheral will enter faulty states because the MCU is not operating with normal execution flows. Note that there are two build options \u2013 debug and release. Debug builds are more helpful when debugging, and release builds are optimized for speed \u2013 up to several orders of magnitude faster. It is helpful to, in CubeIDE, follow these steps: 1. Open \"Properties\" from the \"Project\" dropdown menu at the top of the screen. 2. Open \"C/C++ Build\" > \"Settings\" from the lefthand navigation menu. 3. Select \"Debug\" for the Configuration option 4. Select the \"Tool Settings\" tab. 5. Select \"MCU Post build outputs\" from the lefthand navigation menu 6. Check the \"Convert to binary file\" option 7. Select \"Release\" for the Configuration option 8. Repeat steps 4-6 This will ensure CubeIDE always generates a single machine code binary for developer use within the project directory whenever the project is built. They will be located in the \"Debug\" or \"Release\" folders, depending on which type of build is used. The .bin file is a complete copy of the firmware for the STM32 MCU - it can be moved, saved, shared, as any normal file, as well as copied into the ST-Link's pretend \"External Drive\" to flash the STM32 MCU, independent of CubeIDE.","title":"ST-Link"},{"location":"info/nucleos/#callbacks-and-interrupts","text":"An interrupt is a signal that interrupts the natural flow of a program. This is typically done at a processor level, so interrupts can cause breakaways from practically anywhere in the code. When interrupts trigger, they force the processor to execute a separate segment of code. Only when that segment finishes, does the processor return to where it left off with the original program. HAL functions accomplish a lot of their functionality through callback functions. Callback functions are functions that are \u201cto be called back later\u201d. Interrupts generated by interface peripherals will typically call a callback function, pausing the main execution flow of the program to handle the event generated by the interrupt. For example, if a hardware counter unit on the STM32 MCU is configured to be a timer that generates an interrupt every second \u2013 every second, the hardware counter unit will signal to the processor to stop what it\u2019s doing (perhaps the processor is just waiting in a \u201cwhile true\u201d loop). The processor will enter the callback function labeled HAL_TIM_Callback(), expecting this function has been written to handle what should happen when this timer gives it\u2019s signal. Once that callback function finishes, the processor returns to its \u201cwhile true\u201d loop. Callback functions are \u201cweakly\u201d defined by the HAL \u2013 as soon as the developer redefines the function, the HAL callback function (which is just a placeholder and is functionally empty) is overwritten. This simple method of redefining HAL callback functions is an easy way for developers to write code that responds to events generated by the MCU\u2019s interface peripherals. The HAL documentation lists all the callback functions that can be overwritten.","title":"Callbacks and Interrupts"},{"location":"info/nucleos/#interface-peripherals","text":"Interface peripherals refer broadly to the interfaces onboard the STM32 MCU. These are often implemented in hardware, not software. For example, below is a block diagram for the I2C interface on almost all STM32 F3 series MCU\u2019s. Hardware implemented interfaces have a number of advantages * They don't require processor cycles to operate * They use system clocks and their own state registers, isolating their performance from the rest of the MCU * They only trigger interrupts when meaningful events happen Controlling hardware interface peripherals typically involves writing to and reading from control registers. HAL/LL functions take care of this, abstracting the hardware away from the interfacing. Most interface peripherals can be controlled entirely through HAL functions, though the control registers can be read/written by a developer if necessary.","title":"Interface Peripherals"},{"location":"info/science/","text":"","title":"Science"},{"location":"info/stm32-boot/","text":"Ever wondered what that BOOT0 pin does in the STM32Cube IDE .ioc file or stm32 chip? Want to set the BOOT0 pin to an alternate function such as an I2C CLK? Here is what you need to know before doing so. The BOOT0 pin The BOOT0 pin only really matters for the first 4 clock cycles of the boot sequence after reset has been released. However, it decides where the chip will boot from: Main Flash, System Memory, or Embedded SRAM. (Maybe more or less options depending on the chip). By default, holding BOOT0 LOW will make the chip boot from the main flash - this is most likely where your code is. (When using CubeIDE, this is where it is typically flashed) If it is held high, for example let's say you are using it as an I2C CLK line with an external pull up resistor, this can cause make the chip boot from a region other than flash, which could lead to erratic behavior and floating pins. Alternate Boot Options As you can see from the table below, there are actually other ways of selecting the boot region. In fact, there is one option (row 2) that completely bypasses the BOOT0 pin in order to boot from flash. This is the option we want if using the BOOT0 pin for its alternate functions.\\ \\ STM32 G4 Series Manual Configuring Boot Options The following code was taken from a great stack overflow post . It configures the boot option register and sets nBOOT0 to 1 and nSWBOOT0 to 0. if ((FLASH->OPTR & FLASH_OPTR_nSWBOOT0_Msk) != 0x0 || ((FLASH->OPTR & FLASH_OPTR_nBOOT0_Msk) == 0x0)) { while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0x45670123; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0xCDEF89AB; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x08192A3B; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x4C5D6E7F; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->CR = FLASH->CR | FLASH_CR_OPTSTRT; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } } Here I explain it with some more detail.\\ while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } Polls the flash status register and waits until it is no longer busy. FLASH->KEYR = 0x45670123; \\ FLASH->KEYR = 0xCDEF89AB; Is the sequence of register writes needed to unlock flash for writing/reading. FLASH->OPTKEYR = 0x08192A3B; \\ FLASH->OPTKEYR = 0x4C5D6E7F; Is the sequence of register writes needed to unlock the Options register. FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; Sets nBOOT0 to 1 and nSWBOOT0 to 0. Other Resources STM has other methods of programming these option bits, including using HAL functions. See the following resources for more info. Also make sure to look at the STM reference manual for your particular chip regarding boot options.\\ How to program STM32 Option Bytes with the HAL API \\ What are option bytes in STM32 and how do I use them?","title":"STM32 Boot"},{"location":"info/stm32-boot/#ever-wondered-what-that-boot0-pin-does-in-the-stm32cube-ide-ioc-file-or-stm32-chip-want-to-set-the-boot0-pin-to-an-alternate-function-such-as-an-i2c-clk-here-is-what-you-need-to-know-before-doing-so","text":"","title":"Ever wondered what that BOOT0 pin does in the STM32Cube IDE .ioc file or stm32 chip? Want to set the BOOT0 pin to an alternate function such as an I2C CLK? Here is what you need to know before doing so."},{"location":"info/stm32-boot/#the-boot0-pin","text":"The BOOT0 pin only really matters for the first 4 clock cycles of the boot sequence after reset has been released. However, it decides where the chip will boot from: Main Flash, System Memory, or Embedded SRAM. (Maybe more or less options depending on the chip). By default, holding BOOT0 LOW will make the chip boot from the main flash - this is most likely where your code is. (When using CubeIDE, this is where it is typically flashed) If it is held high, for example let's say you are using it as an I2C CLK line with an external pull up resistor, this can cause make the chip boot from a region other than flash, which could lead to erratic behavior and floating pins.","title":"The BOOT0 pin"},{"location":"info/stm32-boot/#alternate-boot-options","text":"As you can see from the table below, there are actually other ways of selecting the boot region. In fact, there is one option (row 2) that completely bypasses the BOOT0 pin in order to boot from flash. This is the option we want if using the BOOT0 pin for its alternate functions.\\ \\ STM32 G4 Series Manual","title":"Alternate Boot Options"},{"location":"info/stm32-boot/#configuring-boot-options","text":"The following code was taken from a great stack overflow post . It configures the boot option register and sets nBOOT0 to 1 and nSWBOOT0 to 0. if ((FLASH->OPTR & FLASH_OPTR_nSWBOOT0_Msk) != 0x0 || ((FLASH->OPTR & FLASH_OPTR_nBOOT0_Msk) == 0x0)) { while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0x45670123; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->KEYR = 0xCDEF89AB; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x08192A3B; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTKEYR = 0x4C5D6E7F; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } FLASH->CR = FLASH->CR | FLASH_CR_OPTSTRT; while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } } Here I explain it with some more detail.\\ while ((FLASH->SR & FLASH_SR_BSY_Msk) != 0x0) { ; } Polls the flash status register and waits until it is no longer busy. FLASH->KEYR = 0x45670123; \\ FLASH->KEYR = 0xCDEF89AB; Is the sequence of register writes needed to unlock flash for writing/reading. FLASH->OPTKEYR = 0x08192A3B; \\ FLASH->OPTKEYR = 0x4C5D6E7F; Is the sequence of register writes needed to unlock the Options register. FLASH->OPTR = (FLASH->OPTR & ~(FLASH_OPTR_nSWBOOT0_Msk)) | FLASH_OPTR_nBOOT0_Msk; Sets nBOOT0 to 1 and nSWBOOT0 to 0.","title":"Configuring Boot Options"},{"location":"info/stm32-boot/#other-resources","text":"STM has other methods of programming these option bits, including using HAL functions. See the following resources for more info. Also make sure to look at the STM reference manual for your particular chip regarding boot options.\\ How to program STM32 Option Bytes with the HAL API \\ What are option bytes in STM32 and how do I use them?","title":"Other Resources"},{"location":"info/timers/","text":"Timers The following information is for STM32 timers. You will find similar concepts with different microcontrollers; however, the terminology and specifics may differ. Configuring a Timer There are three main parts that can control the behavior of a timer: Prescaler (PSC) Counter Period (also Auto-Reload Register, or ARR) Count & Compare Register (CCR) Let's break down each one: Prescaler (PSC) This value determines the frequency of the timer. The timer frequency is calculated by the following equation: Clock Frequency / (PSC+1) . For example, if our clock frequency is 72 MHz and we set PSC = 71, our timer will tick at a frequency of 1 MHz. Counter Period (Auto-Reload Register, or ARR) This defines the number of ticks in one period. The period is calculated by the following equation: (1 / Timer Frequency) * (ARR + 1) . For example, if our timer frequency is 1 MHz, then the timer will tick every 1000 ns. So, if we set the ARR = 4999, our period will be 0.005 seconds ( 1000 ns * (4999 + 1) = 0.005 s ). Count & Compare Register (CCR) This register holds a specific value that the timer tick counter is compared against. When the counter reaches the value in the CCR, an event is triggered, such as an interrupt or output signal change, which is commonly used for tasks like PWM generation or input capture. Use Cases Periodic Timer Input-Capture Output-Capture PWM What is PWM? PWM (pulse width modulation) is a digital signal that is set to high and low for a set amount of time to represent a percentage. Why do we use PWM? Over a wire, we can only send a value of 0 (low voltage) or 1 (high voltage). However, let's say that I want to control the percent brightness of an LED. How can I send this percentage (a value between 0 and 1) to the LED with just a wire that can only send 0 or 1? This is where PWM comes in. To send a value of 20% (0.20) using PWM, we first set a specified period . Then, for the first 20% of the period, we would set the wire to 1. For the rest of the period, we set the wire to 0. This gives us a duty cycle of 20%. Configuring a STM32 PWM timer For PWM, we will have to modify the PSC, ARR, and CCR registers. The PSC and ARR registers can be modified in the .ioc in order to set a constant period for the PWM signal. Then, in our code we can modify the CCR register in order to set different PWM signals. For normal PWM generation, the PWM signal will be set high in the beginning of the period. Then, when the timer counter goes above the value of CCR, the PWM signal will be set low. If you are still confused, here's a helpful slide deck that goes more in depth.","title":"Timers"},{"location":"info/timers/#timers","text":"The following information is for STM32 timers. You will find similar concepts with different microcontrollers; however, the terminology and specifics may differ.","title":"Timers"},{"location":"info/timers/#configuring-a-timer","text":"There are three main parts that can control the behavior of a timer: Prescaler (PSC) Counter Period (also Auto-Reload Register, or ARR) Count & Compare Register (CCR) Let's break down each one:","title":"Configuring a Timer"},{"location":"info/timers/#prescaler-psc","text":"This value determines the frequency of the timer. The timer frequency is calculated by the following equation: Clock Frequency / (PSC+1) . For example, if our clock frequency is 72 MHz and we set PSC = 71, our timer will tick at a frequency of 1 MHz.","title":"Prescaler (PSC)"},{"location":"info/timers/#counter-period-auto-reload-register-or-arr","text":"This defines the number of ticks in one period. The period is calculated by the following equation: (1 / Timer Frequency) * (ARR + 1) . For example, if our timer frequency is 1 MHz, then the timer will tick every 1000 ns. So, if we set the ARR = 4999, our period will be 0.005 seconds ( 1000 ns * (4999 + 1) = 0.005 s ).","title":"Counter Period (Auto-Reload Register, or ARR)"},{"location":"info/timers/#count-compare-register-ccr","text":"This register holds a specific value that the timer tick counter is compared against. When the counter reaches the value in the CCR, an event is triggered, such as an interrupt or output signal change, which is commonly used for tasks like PWM generation or input capture.","title":"Count &amp; Compare Register (CCR)"},{"location":"info/timers/#use-cases","text":"","title":"Use Cases"},{"location":"info/timers/#periodic-timer","text":"","title":"Periodic Timer"},{"location":"info/timers/#input-capture","text":"","title":"Input-Capture"},{"location":"info/timers/#output-capture","text":"","title":"Output-Capture"},{"location":"info/timers/#pwm","text":"","title":"PWM"},{"location":"info/timers/#what-is-pwm","text":"PWM (pulse width modulation) is a digital signal that is set to high and low for a set amount of time to represent a percentage.","title":"What is PWM?"},{"location":"info/timers/#why-do-we-use-pwm","text":"Over a wire, we can only send a value of 0 (low voltage) or 1 (high voltage). However, let's say that I want to control the percent brightness of an LED. How can I send this percentage (a value between 0 and 1) to the LED with just a wire that can only send 0 or 1? This is where PWM comes in. To send a value of 20% (0.20) using PWM, we first set a specified period . Then, for the first 20% of the period, we would set the wire to 1. For the rest of the period, we set the wire to 0. This gives us a duty cycle of 20%.","title":"Why do we use PWM?"},{"location":"info/timers/#configuring-a-stm32-pwm-timer","text":"For PWM, we will have to modify the PSC, ARR, and CCR registers. The PSC and ARR registers can be modified in the .ioc in order to set a constant period for the PWM signal. Then, in our code we can modify the CCR register in order to set different PWM signals. For normal PWM generation, the PWM signal will be set high in the beginning of the period. Then, when the timer counter goes above the value of CCR, the PWM signal will be set low. If you are still confused, here's a helpful slide deck that goes more in depth.","title":"Configuring a STM32 PWM timer"},{"location":"info/archive/","text":"Archive This page contains archived documentation for older projects. 3BM (2024-2025) Code: mrover-esw/urc-2025 Our brushed motors are controlled with a custom PCB that we call the \"3BM\". This motor controller can control up to three brushed motors. It can support up to two limit switches per motor and a total of one absolute encoder and one quadrature encoder. We communicate with the board using CAN. The board communicates with the absolute encoder using I2C. Code Structure The driver code is in controller.cpp and the main motor control logic is in motor.hpp . Motor CAN IDs and the number of motors is configured in common.hpp . controller.cpp constructs up to three motors, initalizes the CAN bus, and starts the global timers. Architecture Below is a diagram of the 3BM architecture. Timer Overview The 3BM uses seven hardware timers: htim1 ( PWM_TIMER_[0,1,2] ): PWM timer for the three motors ( TIM_CHANNEL_[0,1,2] for motor [0,1,2], respectively) htim2 ( GENERIC_ELAPSED_TIMER ): Repeating count up timer where each tick is 0.001 ms (1000 ns). It used used by: The absolute and quadrature encoder to measure how much time has elapsed since the last reading in order to measure velocity The PIDF controller in order to measure the time elapsed since the last reading to update the \"D\" term htim4 ( QUADRATURE_TICK_TIMER ): Incremental encoder timer configured to read a two-phase quadrature encoder htim6 ( GLOBAL_UPDATE_TIMER ): 20 Hz timer which triggers a CAN FD transmit (sends motor state) htim15 , htim16 , htim17 ( RECEIVE_WATCHDOG_TIMER_[0,1,2] ): FDCAN watchdog timer that needs to be reset every time a message is received SA Arduino (2024-2025) Code: mrover-esw/urc-2025 The Science Acquisition (SA) Arduino is an Arduino MKR WiFi 1010 that is used for two purposes: Read the temperature/humidity sensor ( DFRobot SHT20 ) on the SA sensor actuator Control the servo ( DYNAMIXEL XL330-M288-T ) on the SA hex hub The temp/humidity sensor is read using I2C, and the servo is controlled using the DYNAMIXEL Shield for Arduino MKR . The Arduino communicates with the main rover computer (NVIDIA Jetson AGX Orin) using UART.","title":"Archived Docs"},{"location":"info/archive/#archive","text":"This page contains archived documentation for older projects.","title":"Archive"},{"location":"info/archive/#3bm-2024-2025","text":"Code: mrover-esw/urc-2025 Our brushed motors are controlled with a custom PCB that we call the \"3BM\". This motor controller can control up to three brushed motors. It can support up to two limit switches per motor and a total of one absolute encoder and one quadrature encoder. We communicate with the board using CAN. The board communicates with the absolute encoder using I2C.","title":"3BM (2024-2025)"},{"location":"info/archive/#code-structure","text":"The driver code is in controller.cpp and the main motor control logic is in motor.hpp . Motor CAN IDs and the number of motors is configured in common.hpp . controller.cpp constructs up to three motors, initalizes the CAN bus, and starts the global timers.","title":"Code Structure"},{"location":"info/archive/#architecture","text":"Below is a diagram of the 3BM architecture.","title":"Architecture"},{"location":"info/archive/#timer-overview","text":"The 3BM uses seven hardware timers: htim1 ( PWM_TIMER_[0,1,2] ): PWM timer for the three motors ( TIM_CHANNEL_[0,1,2] for motor [0,1,2], respectively) htim2 ( GENERIC_ELAPSED_TIMER ): Repeating count up timer where each tick is 0.001 ms (1000 ns). It used used by: The absolute and quadrature encoder to measure how much time has elapsed since the last reading in order to measure velocity The PIDF controller in order to measure the time elapsed since the last reading to update the \"D\" term htim4 ( QUADRATURE_TICK_TIMER ): Incremental encoder timer configured to read a two-phase quadrature encoder htim6 ( GLOBAL_UPDATE_TIMER ): 20 Hz timer which triggers a CAN FD transmit (sends motor state) htim15 , htim16 , htim17 ( RECEIVE_WATCHDOG_TIMER_[0,1,2] ): FDCAN watchdog timer that needs to be reset every time a message is received","title":"Timer Overview"},{"location":"info/archive/#sa-arduino-2024-2025","text":"Code: mrover-esw/urc-2025 The Science Acquisition (SA) Arduino is an Arduino MKR WiFi 1010 that is used for two purposes: Read the temperature/humidity sensor ( DFRobot SHT20 ) on the SA sensor actuator Control the servo ( DYNAMIXEL XL330-M288-T ) on the SA hex hub The temp/humidity sensor is read using I2C, and the servo is controlled using the DYNAMIXEL Shield for Arduino MKR . The Arduino communicates with the main rover computer (NVIDIA Jetson AGX Orin) using UART.","title":"SA Arduino (2024-2025)"},{"location":"info/communication-protocols/","text":"Communication Protocols I2C I2C is a synchronous serial communication protocol that is commonly used in embedded systems. On MRover we often use I2C to interface with sensors. I2C has a single leader device and multiple follower devices (traditionally master and slave devices). An example of this is the science board being the leader and multiple sensors being the followers. The leader device controls the clock and initiates communication, while the followers respond when addressed. Each I2C device has a unique 7-bit address allowing for multiple devices to be placed on the same bus. I2C uses two wires, a clock line (SCL) and a data line (SDA). Both lines are open-drain and require pull-up resistors, meaning devices are only able to pull the line low and not drive it high, preventing possible damage. Below is a diagram of a sample I2C bus setup. How Communication Works Each transaction between the leader and a follower begins with a start condition and ends with a stop condition. Start Condition: occurs when the leader pulls SDA low while SCL is held high. Stop Condition: occurs when the leader releases SDA high while SCL is held high. After a start condition the leader sends a message over the bus consisting of: 7-bit address of follower Read/Write bit (0 = write, 1 = read) ACK bit (the addressed follower pulls SDA low to acknowledge its address was received) Then the actual data transfer begins, sending byte-by-byte with each byte followed by an ACK/NACK bit. After all data is sent the leader sends the stop condition and the bus waits for another transaction. CAN Controller Area Network (CAN) is a communication protocol that is used in many embedded systems, especially in industrial and automotive contexts where reliability is important. Devices speak to each other on a CAN bus, which is composed of two wires: CAN High (CANH) and CAN Low (CANL). CAN is a serial, multimaster, multicast protocol, which means that when the bus is free, any node can send a message (multimaster), and all nodes may receive and act on the message (multicast). The CAN protocol has evolved over time. It has three versions, introduced in chronological order: CAN 2.0A CAN 2.0B CAN FD Each version adds more features to the protocol while maintaining backwards compatibility. There are four types of CAN messages, or \u201cframes:\u201d the Data Frame, Remote Frame, Error Frame and Overload Frame. The data frame is the standard CAN message, broadcasting data from the transmitter to the other nodes on the bus. A remote frame is broadcast by a transmitter to request data from a specific node. An error frame may be transmitted by any node that detects a bus error. Overload frames are used to introduce additional delay between data or remote frames. The data frame is the most common frame type and is what this guide will cover. The data frame is made up of two important parts: the identifier and the data. The identifier can be used to determine the priority of the message. The lower the identifier, the higher the priority of the message. Furthermore, the identifier can be used to determine the source of the message, the destination of the message, or the type of message being sent. The data is the actual information being sent by the transmitter to the other nodes on the bus. The length of the identifier and data can vary depending on the version of CAN being used. There are many other fields in the data frame, but for the purposes of this guide, we will only cover the identifier and data. Refer to this document for a more in-depth look at the CAN protocol. CAN 2.0 CAN 2.0A is the original version of the CAN protocol. It supports an identifier up to 11 bits and data packets up to 8 bytes in length. CAN 2.0B is an extension of CAN 2.0A. It supports an identifier of either 11 bits or 29 bits and data packets up to 8 bytes in length. The 29-bit identifier allows for more unique identifiers to be used on the bus. All CAN 2.0 messages can be sent at a maximum rate of 1 Mbps. CAN FD CAN FD is the latest version of the CAN protocol. It supports an identifier of either 11 bits or 29 bits and data packets up to 64 bytes in length. The FD stands for Flexible Data-rate, which means that the data can be sent at a different rate than the rest of the message. This allows for a maximum data rate of 8 Mbps (although 5 Mbps is a more practical limit). The other parts of the message are sent at a maximum rate of 1 Mbps. The rate in which data is sent is often called the \"data rate,\" while the rate in which the rest of the message is sent is called the \"nominal rate.\" As a side note, although CAN FD can send up to 64 bytes of data in a single message, this does not mean that the data payload of the message can be any value up to 64 bytes. The data payload can be the following lengths: 0 to 8, 12, 16, 20, 24, 32, 48, or 64. CAN Bit Timing When using CAN, you will need to configure the bit timing. The bit timing determines how fast we send and receive messages on the CAN bus. The bit timing parameters are: Prescaler Sync Jump Width Time Seg 1 Time Seg 2 For CAN FD, data can be sent at a different rate than the rest of the message. So we end up with two different sets of bit timing parameters: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Data Prescaler Data Sync Jump Width Data Time Seg 1 Data Time Seg 2 For an in-depth guide on what these values mean, this video , although long, is very informative. CAN Bus As mentioned previously, the CAN bus is made up of two wires: CAN High (CANH) and CAN Low (CANL). Microcontrollers, however, do not have the capability to directly interface with the CAN bus. They require a CAN transceiver to convert the digital signals from the microcontroller to the analog signals on the CAN bus. The CAN transceiver also provides protection to the microcontroller from the high voltage on the CAN bus. This is why you will often see CAN TX and RX pins on a microcontroller, but no CANH or CANL pins. The TX and RX pins are connected to the CAN transceiver, which then connects to the CAN bus. Additionally, the CANH and CANL wires are connected to each other at the beginning and end of the bus. This is called termination. The termination is usually done with a 120\u03a9 resistor at each end of the bus. Termination is important because it helps to reduce reflections on the bus, which can cause data errors. Using the Kvaser Bit Timing Calculator We will go over finding these values for STM32 MCUs using an online tool provided by Kvaser. However, the process is similar for other microcontrollers and CAN hardware. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 For these values, we can use an online tool provided by Kvaser. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay We will go over finding these values for STM32 MCUs . The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 0.005 * 1,000,000 = 5,000 ppm The node delay is the max input/output propagation delay of our CAN transceiver. This value is dependent on the CAN transceiver that we are using. For the TCAN1042, the max propagation delay is 175 ns as shown below. Refer to the datasheet of the transceiver you are using to find this value. With these values, we can now use the Kvaser tool to calculate the bit timing values for our CAN bus. Scroll down to 1. Device Characteristics and make sure to delete the default device that has been added. Then, input the clock frequency, clock tolerance, and node delay. Click Add CAN Device . Then, scroll down to 2. Bitrates and input the desired bitrate for the CAN bus. Click Recalculate . Now in sections 3.1 and 3.2 , you can make changes to the nominal and data sample point percentages. Any percentage from 50% to 90% is acceptable. Many automotive applications use a value around 87.5% for nominal and around 70% - 80% for data. Finally, scroll down to 4. Individual Bus Timing Parameters and you will see the values for the bit timing parameters. You may also modify the prescaler (the data prescaler must be equal to 1 or 2).","title":"Communication Protocols"},{"location":"info/communication-protocols/#communication-protocols","text":"","title":"Communication Protocols"},{"location":"info/communication-protocols/#i2c","text":"I2C is a synchronous serial communication protocol that is commonly used in embedded systems. On MRover we often use I2C to interface with sensors. I2C has a single leader device and multiple follower devices (traditionally master and slave devices). An example of this is the science board being the leader and multiple sensors being the followers. The leader device controls the clock and initiates communication, while the followers respond when addressed. Each I2C device has a unique 7-bit address allowing for multiple devices to be placed on the same bus. I2C uses two wires, a clock line (SCL) and a data line (SDA). Both lines are open-drain and require pull-up resistors, meaning devices are only able to pull the line low and not drive it high, preventing possible damage. Below is a diagram of a sample I2C bus setup.","title":"I2C"},{"location":"info/communication-protocols/#how-communication-works","text":"Each transaction between the leader and a follower begins with a start condition and ends with a stop condition. Start Condition: occurs when the leader pulls SDA low while SCL is held high. Stop Condition: occurs when the leader releases SDA high while SCL is held high. After a start condition the leader sends a message over the bus consisting of: 7-bit address of follower Read/Write bit (0 = write, 1 = read) ACK bit (the addressed follower pulls SDA low to acknowledge its address was received) Then the actual data transfer begins, sending byte-by-byte with each byte followed by an ACK/NACK bit. After all data is sent the leader sends the stop condition and the bus waits for another transaction.","title":"How Communication Works"},{"location":"info/communication-protocols/#can","text":"Controller Area Network (CAN) is a communication protocol that is used in many embedded systems, especially in industrial and automotive contexts where reliability is important. Devices speak to each other on a CAN bus, which is composed of two wires: CAN High (CANH) and CAN Low (CANL). CAN is a serial, multimaster, multicast protocol, which means that when the bus is free, any node can send a message (multimaster), and all nodes may receive and act on the message (multicast). The CAN protocol has evolved over time. It has three versions, introduced in chronological order: CAN 2.0A CAN 2.0B CAN FD Each version adds more features to the protocol while maintaining backwards compatibility. There are four types of CAN messages, or \u201cframes:\u201d the Data Frame, Remote Frame, Error Frame and Overload Frame. The data frame is the standard CAN message, broadcasting data from the transmitter to the other nodes on the bus. A remote frame is broadcast by a transmitter to request data from a specific node. An error frame may be transmitted by any node that detects a bus error. Overload frames are used to introduce additional delay between data or remote frames. The data frame is the most common frame type and is what this guide will cover. The data frame is made up of two important parts: the identifier and the data. The identifier can be used to determine the priority of the message. The lower the identifier, the higher the priority of the message. Furthermore, the identifier can be used to determine the source of the message, the destination of the message, or the type of message being sent. The data is the actual information being sent by the transmitter to the other nodes on the bus. The length of the identifier and data can vary depending on the version of CAN being used. There are many other fields in the data frame, but for the purposes of this guide, we will only cover the identifier and data. Refer to this document for a more in-depth look at the CAN protocol.","title":"CAN"},{"location":"info/communication-protocols/#can-20","text":"CAN 2.0A is the original version of the CAN protocol. It supports an identifier up to 11 bits and data packets up to 8 bytes in length. CAN 2.0B is an extension of CAN 2.0A. It supports an identifier of either 11 bits or 29 bits and data packets up to 8 bytes in length. The 29-bit identifier allows for more unique identifiers to be used on the bus. All CAN 2.0 messages can be sent at a maximum rate of 1 Mbps.","title":"CAN 2.0"},{"location":"info/communication-protocols/#can-fd","text":"CAN FD is the latest version of the CAN protocol. It supports an identifier of either 11 bits or 29 bits and data packets up to 64 bytes in length. The FD stands for Flexible Data-rate, which means that the data can be sent at a different rate than the rest of the message. This allows for a maximum data rate of 8 Mbps (although 5 Mbps is a more practical limit). The other parts of the message are sent at a maximum rate of 1 Mbps. The rate in which data is sent is often called the \"data rate,\" while the rate in which the rest of the message is sent is called the \"nominal rate.\" As a side note, although CAN FD can send up to 64 bytes of data in a single message, this does not mean that the data payload of the message can be any value up to 64 bytes. The data payload can be the following lengths: 0 to 8, 12, 16, 20, 24, 32, 48, or 64.","title":"CAN FD"},{"location":"info/communication-protocols/#can-bit-timing","text":"When using CAN, you will need to configure the bit timing. The bit timing determines how fast we send and receive messages on the CAN bus. The bit timing parameters are: Prescaler Sync Jump Width Time Seg 1 Time Seg 2 For CAN FD, data can be sent at a different rate than the rest of the message. So we end up with two different sets of bit timing parameters: Nominal Prescaler Nominal Sync Jump Width Nominal Time Seg 1 Nominal Time Seg 2 Data Prescaler Data Sync Jump Width Data Time Seg 1 Data Time Seg 2 For an in-depth guide on what these values mean, this video , although long, is very informative.","title":"CAN Bit Timing"},{"location":"info/communication-protocols/#can-bus","text":"As mentioned previously, the CAN bus is made up of two wires: CAN High (CANH) and CAN Low (CANL). Microcontrollers, however, do not have the capability to directly interface with the CAN bus. They require a CAN transceiver to convert the digital signals from the microcontroller to the analog signals on the CAN bus. The CAN transceiver also provides protection to the microcontroller from the high voltage on the CAN bus. This is why you will often see CAN TX and RX pins on a microcontroller, but no CANH or CANL pins. The TX and RX pins are connected to the CAN transceiver, which then connects to the CAN bus. Additionally, the CANH and CANL wires are connected to each other at the beginning and end of the bus. This is called termination. The termination is usually done with a 120\u03a9 resistor at each end of the bus. Termination is important because it helps to reduce reflections on the bus, which can cause data errors.","title":"CAN Bus"},{"location":"info/communication-protocols/#using-the-kvaser-bit-timing-calculator","text":"We will go over finding these values for STM32 MCUs using an online tool provided by Kvaser. However, the process is similar for other microcontrollers and CAN hardware. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 For these values, we can use an online tool provided by Kvaser. The tool requires three values that are properties of the hardware you are using: Clock Frequency Clock Tolerance Node Delay We will go over finding these values for STM32 MCUs . The clock frequency of the FDCAN peripheral is based on the system clock. It can be found and modified by the user in the Clock Configuration tab of the .ioc in STM32CubeIDE. The example below shows a clock configuration where the FDCAN peripheral clock frequency is 64 MHz. The clock tolerance (measured in ppm) is a physical characteristic of the clock of the CAN FD hardware. Based on the specific clock configuration shown above, we can see that the FDCAN peripheral is using PCLK1 (FDCAN Clock Mux). PCLK1 is based on PLLCLK (System Clock Mux). Finally, PLLCLK is based on HSI16 (PLL Source Mux). We can find the characteristics in the datasheet. The table with the characteristics of the HSI16 oscillator for the STM32G431 is shown below. We then perform the following calculation: (16.08 - 16) / 16 = 0.005 0.005 * 1,000,000 = 5,000 ppm The node delay is the max input/output propagation delay of our CAN transceiver. This value is dependent on the CAN transceiver that we are using. For the TCAN1042, the max propagation delay is 175 ns as shown below. Refer to the datasheet of the transceiver you are using to find this value. With these values, we can now use the Kvaser tool to calculate the bit timing values for our CAN bus. Scroll down to 1. Device Characteristics and make sure to delete the default device that has been added. Then, input the clock frequency, clock tolerance, and node delay. Click Add CAN Device . Then, scroll down to 2. Bitrates and input the desired bitrate for the CAN bus. Click Recalculate . Now in sections 3.1 and 3.2 , you can make changes to the nominal and data sample point percentages. Any percentage from 50% to 90% is acceptable. Many automotive applications use a value around 87.5% for nominal and around 70% - 80% for data. Finally, scroll down to 4. Individual Bus Timing Parameters and you will see the values for the bit timing parameters. You may also modify the prescaler (the data prescaler must be equal to 1 or 2).","title":"Using the Kvaser Bit Timing Calculator"},{"location":"projects/overview26/","text":"ESW 2025-2026 Projects Information about the projects for the ESW 2025-2026 academic year can be found in this Google Doc .","title":"ESW 2025-2026 Projects"},{"location":"projects/overview26/#esw-2025-2026-projects","text":"Information about the projects for the ESW 2025-2026 academic year can be found in this Google Doc .","title":"ESW 2025-2026 Projects"}]}